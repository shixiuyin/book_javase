{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:16 "},"content/day01/day01.html":{"url":"content/day01/day01.html","title":"第一章:java语言概述","keywords":"","body":" 第一节：java语言概述 一、java简介[了解] 1.java概述 1.1java是什么? 1.2java名称的由来 1.3为什么学习java? 2.java发展史 3.Java语言特点 4.java语言的构成 二、java快速入门[重点] 2.1.基础常识 2.2什么是计算机语言 2.3编写第一个 Java应用程序 2.3.1 什么是JDK, JRE 2.3.2 下载及安装 JDK 2.3.3配置环境变量: 2.3.4 显示已知文件的扩展名 2.3.5编写源代码 2.3.6 编译 4.4案例 4.5 练习 三、java语言的运行机制 2.1 JVM 2.2.GC 垃圾回收器 四、eclipse编译工具 使用 第一节：java语言概述 一、java简介[了解] 1.java概述 1.1java是什么? ​ 学习之前需要了解,java是什么。java是sun公司推出的面向对象程序设计语言，特别适用于Interent应用程序开发,它的最大特点就是“一次编译，到处运行”,并且能够在各种操作系统上运行,例如:windows,linux等。 1.2java名称的由来 ​ Java是印度尼西亚爪哇岛的英文名称，因盛产咖啡而闻名。Java语言中的许多库类名称，多与咖啡有关，如JavaBeans(咖啡豆)、NetBeans(网络豆)以及ObjectBeans (对象豆)等等。SUN和JAVA的标识也正是一杯正冒着热气的咖啡。Java自1995诞生，至今已经20多年的历史。 1.3为什么学习java? ​ java可以说是无处不在，其市场占有率也在不断攀升。他已经吸收了全球最大的开发者队伍---500W+开发者这是全球最大最具活力的开发团队。 ​ 目前采用java的设备已经超过45亿，其中报告8亿台个人计算机、15亿部移动电话及其其他手持设备、22亿智能卡，以及机顶盒、打印机、网络照相机、游戏、汽车导航系统、彩票终端、医疗设备、收费站等。 以下是最新的编程语言排行榜： 2019年03月编程语言排行榜TOP 10 榜单 https://hellogithub.com/report/tiobe/?url=/ 排名 编程语言 流行度 对比上月 年度明星语言 1 Java 14.880% 0.996% 2015, 2005 2 C 13.305% 0.881% 2017, 2008 3 Python 8.262% 0.688% 2010, 2007, 2018 4 C++ 8.126% 0.682% 2003 5 Visual Basic .NET 6.429% 0.666% 6 C# 3.267% 0.421% 7 JavaScript 2.426% 0.422% 2014 8 PHP 2.420% 0.149% 2004 9 SQL 1.926% 0.026% 10 Objective-C 1.681% 0.234% 2012, 2011 2.java发展史 1995年5月23日，Java语言诞生 1996年1月，第一个JDK-JDK1.0诞生 1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术 1996年9月，约8.3万个网页应用了JAVA技术来制作 1997年2月18日，JDK1.1发布 1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录 1997年9月，JavaDeveloperConnection社区成员超过十万 1998年2月，JDK1.1被下载超过2,000,000次 1998年12月8日，JAVA2企业平台J2EE发布 1999年6月，SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME） 2000年5月8日，JDK1.3发布 2000年5月29日，JDK1.4发布 2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机 2001年9月24日，J2EE1.3发布 2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升 2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0 2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME 2006年12月，SUN公司发布JRE6.0 2009年4月20日，Oracle以74亿美元收购Sun公司，取得了java的版权。 2009年12月，SUN公司发布Java EE 6 2010年11月，由于Oracle公司对于Java社群的不友善，因此Apache扬言将退出JCP java之父James Gosling 加盟google 2011年7月28日，Oracle公司发布Java SE 7 2014年3月18日，Oracle公司发表Java SE 8 2017年9月21日，Oracle公司发表Java SE 9 2018年3月21日，Oracle公司发表Java SE 10 2018年9月25日，Java SE 11发布 3.Java语言特点 ​ Sun公司在1995年推出java时，发布了一个java白皮书，并这样定义java语言：java是一种简单的（Simple）、面向对象（Object-Oriented）、分布式的（Distributed）、解释的（Interpreted）、健壮的（Robust）、安全的（Secure）、结构中立的（Architecture-neutral）、可移植的（Portable）、高性能的（High-Performance）、多线程的（Multi-Threaded）、动态的（Dynamic）的语言。 ​ 通过这11个词语来概括java语言的特性，下面来看下每个词语所代表的含义。 ​ 1.简单的（Simple） 风格和C++很像，基本语法和C很像，但是摒弃了C++容易引发错误的地方，如指针、内存管理、头文件等。 提供了丰富的类库。 2.面向对象（Object-Oriented） 简单的来说，面向对象设计就是一种程序设计技术。它将重点放在了数据（也就是对象）和对象的接口上。 3.分布式的（Distributed） Java是针对Internet的分布式环境而设计的，所以它包含了一个支持HTTP和FTP等基于TCP/IP协议的子库，它能处理TCP/IP协议。Java应用程序可以凭借URL打开并访问网络上的对象。实际上使用URL访问资源与访问文件没有什么太大的区别。 4.解释的（Interpreted） Java解释器可以在任何移植了解释器的机器上Java字节码。现在使用即时编译器将字节码翻译成机器码。 5.健壮的（Robust） Java是强制类型的语言，它不仅在运行时检查代码，还在编译时就检查代码，消除有出错倾向的状态。 Java自己操纵内存，减少了内存出错的可能性。（垃圾回收功能） 实现了真数组，避免了覆盖数据的可能。 6.安全性（Secure） 指针和释放内存等C++功能被删除，避免了非法内存操作。 当Java用来创建浏览器时，语言功能和一些浏览器本身提供的功能结合起来，使它更安全。 7.结构中立的（Architecture-neutral） 编译器生成一个体系结构中立的高层次的与机器无关的byte-code格式语言，被设计在Java虚拟机上运行。这是一种编译过的代码，只要有Java运行时系统，就可以在许多处理机上运行。解释字节码会比全速运行机器指令慢很多，但是虚拟机有一个选项，可以将使用最频繁的字节码序列翻译成机器码，这一过程被称为及时翻译。 8.可移植的（Portable） Java定义了独立于平台的基本数据类型及其运算，消除了代码移植时让人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。 9.高性能的（High-Performance） Java通过使用及时编译器，可以很容易的将字节码转换为运行这个应用程序的特定CPU的机器码。 10.多线程的（Multi-Threaded） 多线程可以提供更好的交互性能和实时控制性能。Java的设计目标之一是满足对创建交互式、网络化程序的现实需求。只需要考虑程序的特定行为，而不需要考虑多任务子系统。 11.动态的（Dynamic） Java的动态性是其面向对象设计方法的拓展，它允许程序动态地装入运行过程中所需要的类。 其中可以简单的概括为以下三个重要的特点: 特点一：面向对象 两个基本概念：类、对象 三大特性：封装、继承、多态 特点二：健壮性 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分。如：指针、内存的申请与释放等 特点三：跨平台性 跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。 原理： 只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。 由JVM来负责Java程序在该系统中的运行。 4.java语言的构成 ​ 所谓java的构成，就是值java运行环境的组成，从核心到外围包括 JIT、JVM、JRE、JDK，四种区别如下： JDK:是Java Develop ToolKit的缩写，它里面有很多java所编写的开发工具(如:javac.exe、jar.exe),还包括了一个jre的调试环境。 JRE:是Java Runtime Environment的缩写，是java运行的基础，它提供了java运行的API,Java程序必须有JRE才能正常运行。 JVM:是Java Vitual Machine的缩写，它是java运行的虚拟机环境. JIT:是Java In Time的缩写，即java即时编译器，是JVM的一部分，属于内核部分。 其中的JVM是java运行的虚拟机环境，它是Java运行环境的重要一环 二、java快速入门[重点] 2.1.基础常识 人机交互方式： ​ 图形化界面(GraphicalUser Interface GUI)这种方式简单直观，使用者易于接受，容易上手操作。 ​ 命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 常用的DOS命令: 常用的DOS命令 dir（directory） : 列出当前目录下的文件以及文件夹 md（make directory） : 创建目录 rd（remove directory） : 删除目录 cd（change directory）: 进入指定目录 cd.. : 退回到上一级目录 cd \\: 退回到根目录 exit : 退出 dos 命令行 2.2什么是计算机语言 语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，就要学习英语。 计算机语言（编程语言）：人与计算机交流的方式。如果人要与计算机交流，那么就要学习计算机语言。计算机语言有很多种，如：C，C++，Java，PHP等。 步骤(记事本): 1.安装java运行环境(JDK) 2.编写源代码 3.编译源代码 javac 4.运行编译后的class文件 java 2.3编写第一个 Java应用程序 实现步骤： 1.什么是JDK, JRE 2.下载及安装 JDK 3.编写第一个 Java 应用程序 a.显示已知文件类型的扩展名 b.配置环境变量 path c.main 方法和输出语句 d.注释 e.其它细节 2.3.1 什么是JDK, JRE 简单而言，使用 JDK 的提供的开发工具完成 java 程序的开发，使用 JRE 运行开发好的 Java 应用程序。 JDK(Java Development Kit Java开发工具包)：JDK是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了 JRE(Java Runtime Environment Java运行环境) ：包括Java虚拟机(JVM：Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JDK包含了JRE,JRE包含了JVM. 2.3.2 下载及安装 JDK 下载： 官方网址： https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html、 安装JDK: ​ - 傻瓜式安装，下一步即可。 ​ - 建议：安装路径不要有中文或者特殊符号如空格等。 ​ - 当提示安装 JRE 时，可以选择不安装。 默认安装路径: C:\\Program Files\\Java 2.3.3配置环境变量: 第一步:打开-计算机-属性-高级系统设置-环境变量-系统变量 第二步:进行配置（JAVA_HOME,PATH,CLASSPATH） a.JAVA_HOME:另似给jdk全路径取一个别名。然后使用的时候直接使用别名 b.PATH:通过PATH,在DOS命令行找到对应的命令。java javac c.CLASSPATH:JDK1.5之后，可以选择性安装，建议安装。最前面一定要配置一个.(点) 参考配置如下: JAVA_HOME = C:\\Program Files\\Java\\jdk1.8.0_73 PATH = %JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH = .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar; 2.3.4 显示已知文件的扩展名 查看本地地方文件夹 2.3.5编写源代码 1.创建文本文件修改后缀为.java；例如:HelloWrold.java 2.文件名必须和源代码中的class类名保持一致 //HelloWorld由于被public 修饰，所有必须和文件名保持一致 public class HelloWorld{ //程序的入口 public static void main(String[] args){ //打印信息到控制台 System.out.println(\"hello bj1901.....\"); } } 3.具体细节如下: - main的方法： Java应用程序的执行入口是main()方法。它有固定的书写格式： public static void main(String[] args) {...} 如果没有 main 方法则在运行时会抛出如下异常 【java.lang.NoSuchMethodError:main】 - 想要和JVM来个互动，只要在main方法中加入一句System.out.println(“Hello World”); - 一个 Java 源文件中最多只能有一个 public 类。其它类的个数不限， 如果源文件文件包含一个 public 类，它必 须是该类名命名。 - Java 语言严格区分大小写。 - Java方法由一条条语句构成，每个语句以分号结束。 4.java注释 注释：用于解释说明程序的文字、提高了代码的阅读性 Java中的注释类型： ​ - 单行注释 ​ - 多行注释 ​ - 文档注释（java 特有） 注释是一个程序员必须要具有的良好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现 单行注释 格式： //注释文字 多行注释 格式： /* 注释文字 */ 对于单行和多行注释，被注释的文字，不会被JVM（java虚拟机）解释执行。多行注释里面不允许有多行注释嵌套。 2.3.6 编译 java提供了javac命令用于编译： 编译HelloWorld.java文件，编译成功会生成HelloWorld.class文件 - javac HelloWorld.java 运行 - java HelloWorld 4.4案例 public class Test01{ public static void main(String [] args){ System.out.println(\"-------------------------\"); //注释：是一个制表符 tab键 System.out.println(\"\\t欢迎光临家乐福西乡店\"); System.out.println(\"机:15 \\t 人:1082 \\t 单:7596\"); System.out.println(\"\\t\\t\\t\\t\\tRMB\"); System.out.println(\"商品号\\t110 清风抽取式面纸 \\t\\t25.30\"); System.out.println(\"商品号\\t111 统一方便面 \\t\\t12.56\"); System.out.println(\"-------------------------\"); System.out.println(\"总价\\t\\t\\t\\t\\t37.86\"); System.out.println(\"-------------------------\"); } } 4.5 练习 开发出如下界面: 练习1: ********************************** 魔法饰品分发系统 1.登录系统 2.退出 ********************************** 请选择输入数字: 练习2： 魔法饰品分发系统 ********************************** 1.账号信息管理 2.购物结算 3.装备返点 4.注销 *********************************** 请选择输入数字: 三、java语言的运行机制 1.JVM(java虚拟机) 2.GC(垃圾回收器) 2.1 JVM 概念:JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器 java是跨平台的语言(windows,linux,mac): 怎么实现跨平台的:因为不同的操作系统（平台）拥有不同的虚拟机。 Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”。 2.2.GC 垃圾回收器 1.系统开辟一个线程自动检测哪些对象不再被使用，然后将这些空闲的对象及资源进行回收。（c,c++需要手动回收） 2.在系统运行的时候，会自动去执行。我们人工无法精确的取控制和干预. 四、eclipse编译工具 使用 1.解压直接使用 2.第一次进来选择工作空间，就是存放代码的地方(建议放在D盘) 3.修改eclipse的编码方式(UTF-8:万国码，国标码:GB2312,GBK) 4.修改字体大小 5.新建项目 6.创建具体的java类 选中项目，然后先建class。然后设置class名称 This text is highlighted ! This text is highlighted with markdown! This text is highlighted in green! This text is highlighted in red! This text is highlighted with a custom color! var gitalk = new Gitalk({ clientID: '2eb19afceda708b27e64', // GitHub Application Client ID clientSecret: '36aedb5a30321626a8631689fee5fafd5929f612', // GitHub Application Client Secret repo: 'bookcommont', // 存放评论的仓库 owner: 'hzittest', // 仓库的创建者， admin: ['hzittest'], // 如果仓库有多个人可以操作，那么在这里以数组形式写出 id: location.pathname, // 用于标记评论是哪个页面的，确保唯一，并且长度小于50 }); gitalk.render('gitalk-container'); // 渲染Gitalk评论组件 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day02/day02.html":{"url":"content/day02/day02.html","title":"第二章:数据类型|运算符|变量","keywords":"","body":" 一、回顾 二、关键字 1.含义 2.具体的关键字 三、标识符 1.含义 2.命名的规则 3.java标识符的命格规则 四、变量 1.概念 2.定义格式 3.变量的分类 a.按照申明(创建)的位置划分 b.按照数据类型划分 4.数据类型的转换 五、运算符 1.算术运算符 2.比较运算符 3.逻辑运算符 4.三元运算符 day02_关键字、运算符、数据类型 一、回顾 1.java的概述 2.java的发展历史 1995：诞生 2004:发布1.5 改名为5.0 2009:Sun被Oracle收购 2018:java11 3.环境变量的搭建 JAVA_HOME=JDK的安装路径(本地的路径:C:\\Program Files\\Java\\jdk.version) Path(不需要重新创建):%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin; CLASSPATH:.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar 4.编写源代码 public class 类名{ //main方法 程序的入口 public static void main(String [] args) { //具体的业务.... } } 5.使用javac命令进行编译。xxx.java---->xxx.class 例如:javac Hello.java ------>Hello.class 6.使用java命令执行class文件 java Hello 7.JVM (java虚拟机) 提供了不同平台的虚拟机。完成跨平台; 8.使用eclipse 今天主要内容: 2.1 关键字 2.2 标识符 2.3 变 量 2.4 运算符 二、关键字 1.含义 被java赋予了特殊含义，用作专门用途的字符串。例如:public:表示公共的 class:定义类 特点:所有的单词都是小写 goto:表示java的预留关键字 2.具体的关键字 三、标识符 1.含义 Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 凡是自己可以起名字的地方都叫标识符。 2.命名的规则 1.由26个英文字母大小写，数字：0-9 ，_或 $ 组成 2.数字不可以开头。 3.不可以使用关键字和保留字，但能包含关键字和保留字。 4.Java中严格区分大小写，长度无限制。 5.标识符不能包含空格。 注意：取名满足见名知意，长度不宜过长。小于30个字符; 3.java标识符的命格规则 很多公司里面，对命名有严格的要求 1.包名： xxxyyyzzz 所有的名称都是小写; 多个单词都是小写； 可以使用.创建多层包名 2.类名和接口名 XxxYyyZzz 首字母大写； 多个单词组成，首字母都是大写; 3.变量和方法名 xxxYyyZzz 首个单词首字母小写； 多个单词组成，除了第一个单词首字母小写，其余单词首字母大写; 4.常量的名称 XXX_YYY_ZZZ 常量的名称都是大写； 多个单词组成使用下划线链接; 四、变量 1.概念 内存中的一个存储区域; 该区域有自己的名称（变量名）和类型（数据类型）; Java中每个变量必须先声明，后使用; 该区域的数据可以在同一类型范围内不断变化; 变量是通过使用变量名来访问这块区域的; 变量的作用域：一对{ }之间有效 2.定义格式 数据类型 变量名 = [初始值]; 例如:int num1 = 90; 3.变量的分类 a.按照申明(创建)的位置划分 1.成员变量|全局变量|属性 a.定义在方法的外部，类的内部; b.范围在该类下所有的地方都可以使用,包括里面多个方法内部; 2.局部变量 a.定义在方法或者代码块的内容; b.只在定义的方法或者代码块的{}里面使用; 之间的区别: a.定义位置不一样; b.局部变量在使用之前必须赋值。全局变量会生成对应数据类型的默认值; b.按照数据类型划分 1.基本数据类型 数值型: 整数型: byte: short: int: long: 默认的类型是int 浮点型: float double: Java 的浮点型常量默认为 double 型，声明 float 型常量，须后加 ‘f’ 或 ‘F’。 字符型: char: a.使用 '' 单引号定义内容; b.可以存放一个中文 c.可以存放Java中还允许使用转义字符‘\\’来将其后的字符转变为特殊字符型常量。例如：char c3 = '\\n'; -- '\\n'表示换行符 d.直接使用 Unicode 值来表示字符型常量：‘\\uXXXX’。其中，XXXX代表一个十六进制整数。如： \\u000a 表示 \\n。 e.char 类型是可以进行运算的。因为它都对应有 Unicode 值。 布尔型: boolean: boolean类型数据只允许取值true和false 2.引用数据类型 4.数据类型的转换 1.自动转换 从小到大； byte bt1 = 80; int num1 = bt1; 2.强制转换:语法 需要转换变量的前面 添加 （） long num1 = 900; int num2 = (int)num1; char和byte,short不能只能转换,通过int 3.浮点型转换为整形，丢失精度 double d1 = 99.9; int num3 = (int) d1; System.out.println(\"d1:\" + d1); System.out.println(\"num3:\" + num3); 五、运算符 算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 1.算术运算符 2.比较运算符 3.逻辑运算符 4.三元运算符 格式: (条件运算符) ?结果1：结果2 ​ 条件运算符:true 取结果1 ​ 条件运算符:false 取结果2 // 判断num1是否大于等于100 // 如果条件为true ： result = num1 // 如果条件为false: reslut = 60 int result = (num1 >= 100) ? num1 : 60; String str = (num1 >= 60) ? \"优秀\" : \"不及格\"; System.out.println(\"str=\" + str); powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day03/day03.html":{"url":"content/day03/day03.html","title":"第三章:分支语句","keywords":"","body":" 一、回顾 二、分支语句 三、if....else 四、switch day03_分支语句 一、回顾 1.关键字 2.标识符 自己定义的内容。 类名:首字符大写 包名:小写，可以使用.分层 方法或变量名:驼峰命名 首个单子小写，其余单词首字母大写 常量:大写,多个单词之间使用下划线 分开 3.变量 全局变量: a.定义范围在类中，方法的外面; b.作用域整个类中,可用 ;一对{}中可用 c.全局变量有初始值。 byte,short,int,long:0 float,double:0.0 boolean:false char:空'',引用:null 局部变量: a.定义在方法或者代码块中; b.作用域只在该放或者代码块内部使用; c.使用之前必须赋值; 4.数据类型 基本数据类型: byte,short,int,long ,float,double, boolean,char 引用数据类型: 除了基本数据类型以为，都是引用数据类型。默认值都是null。（String,自己的类，Scanner...） 数据类型的转换: 自动转换:从小到大 强制转换:从大到写，丢失精度和数据; 5.运算符 a.算术运算符 b.赋值运算符 c.逻辑运算符 d.比较运算符 e.三元运算符 f.位运算符 a.i++(先赋值，在运算) 和 ++i(先运算，在赋值) b.&和&&的区别 i:&除了是用and之外，还有位运算的功能 ii:&没有短路的功能。 iii:&&有短路的功能,避免不必要的判断; c.三元运算符(if...else) 格式:数据类型 变量 = （条件）?\"成功\":\"失败\"; boolean boolean = (num>20)?true:false; 今天主要内容: 1.if..else 2.switch 二、分支语句 分支语句根据一定的条件有选择地执行或跳过特定的语句 三、if....else if...else主要分为三种实现方式: 1.单分支语句 只有一个 if(){} 如果满足条件执行。否则直接跳过 if (score > 90) { // 业务 System.out.println(\"你很优秀...\"); } 2.双分支语句 if (score > 90) { // 业务 System.out.println(\"你很优秀...\"); } else { System.out.println(\"继续努力....\"); } 3.多分支语句 if (age > 65) { System.out.println(\"老年\"); } else if (age > 40) { System.out.println(\"中年\"); } else if (age > 17) { System.out.println(\"青年\"); } else if (age > 6) { System.out.println(\"少年\"); } else if (age > 0) { // 以上都不满足 进入else System.out.println(\"童年\"); } else { System.out.println(\"非法输入..\"); } 四、switch 1.语法 switch(表达式){ case 常量1: 语句1; break; case 常量2: 语句2; break; … … case 常量N: 语句N; break; [default: 语句; break;] } 2.break 跳出switch语句块，不继续往下执行; 3.表达式的类型 目前支持:byte,short,char,int,字符串，枚举 4.case语句内容不能相同。 5.default是可选的。当case都不满足的时候，进入default powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day04/day04.html":{"url":"content/day04/day04.html","title":"第四章:循环语句","keywords":"","body":" 一、回顾 二、循环语句 三、for循环 四、while循环 五、break,continue 六、嵌套循环 day04_循环语句 一、回顾 1.if 单分支 双分支 多分支 if(条件){} //当满足条件为true的时候，进入语句块; 如果只有一行代码，可以省略{} 2.switch switch...case: a.swith数据类型:byte,char,short,int,枚举,字符串(String) b.case值必须是常量，不能有重复值 c.多个case可以共用一个语句块 d.break 可以跳出语句块，不继续往下执行 e.default 当所有case都没有进去，进入default。 只要内容 1.for 普通for,增强for 2.while while do...while 二、循环语句 功能: 在满足指定条件下，反复执行特定的代码。 组成部分: a.初始化 b.循环条件 c.循环体,循环的内容 d.迭代(改变原来的值) 三、for循环 语法: for(初始化;条件判断;迭代) { //循环体 具体反复执行的代码 } public static void main(String[] args) { for (int i = 1; i 执行顺序: 四、while循环 语法格式(先判断，再执行): [初始值] while(条件) { //语句块 // 迭代[更改初始值] } 案例 ： public static void main(String[] args) { // int result = 0; // for (int i = 1; i do...while 语法格式:(先执行，在判断:不管条件如何，都会至少执行一次) [初始化内容] do{ //语句块 [迭代] }while(判断条件); public static void main(String[] args) { int result = 0; int i = 1; do { result += i; System.out.println(\"i=\" + i + \" result=\" + result); i++; } while (i 五、break,continue 1.continue 跳过本次循环，继续执行下一次循环。 1234 6789 2.break 跳出整个循环(默认跳出最近的一个循环) 1234 注意: break只能用于switch语句和循环语句中。 continue 只能用于循环语句中。 标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。 break和continue之后不能有其他的语句，因为程序永远不会执行break 和 continue之后的语句。 六、嵌套循环 九九乘法表 public static void main(String[] args) { // 1. 外层: 控制行数 1-9行 // 2.内层 :控制每一行 有多少个列（需要计算多杀次） for (int i = 1; i 断点调试 基本步骤: 1.在需要打断点调试的地方，左侧，双击出现小圆点 2.使用debug as 启动 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day05/day05.html":{"url":"content/day05/day05.html","title":"第五章:数组","keywords":"","body":" 一、回顾 二、数组 day05_数组 一、回顾 1.java的环境搭建 2.标识符、关键字、变量、数据类型、运算符 3.分支语句:if..else switch...case 4.循环语句：for while do.while a.循环:满足特定条件下，重复执行的代码 b.四大组成部分:初始化,条件判断,语句块,迭代 c.for:语法 for(初始化;判断条件;迭代) { //循环语句 } 执行顺序: 初始化(执行一次);判断条件;循环语句;迭代;..判断条件...... d.while:for循环可以做的事情，while都可以做 语法: [初始化] while(判断条件) { //语句块 [迭代] } do...while:先执行一遍，在去判断。始终都会执行一次; 语法:[初始化] do{ //语句块 [迭代] }while(判断条件); e.break,continue break:默认跳出最近的一个循环。可以使用标识 (语句:) break 标识; continue:默认跳出本次循环，继续执行下一次循环; 标识:必须写在循环体的前面 f.循环嵌套 主要内容:数组的创建及使用 二、数组 1.概述 数组是多个相同类型数据的组合，实现对这些数据的统一管理 数组中的元素可以是任何数据类型，包括基本类型和引用类型 数组属引用类型，数组型数据是对象(Object)，数组中的每个元素相当于该对象的成员变量,拥有初始值 2.作用 变量:存储单个类似单个可变的数据 常量:存储单个类型单个不可变的量 数组:存储单个类型多个可变的量,但是大小是固定。 集合:存储任意类似的任意多个数据 IO流:存储数据到磁盘 数据库:关系型数据库，非关系数据库.... 3.数据的创建方式 提供申明两种方式 a.type [] 变量名; b.type 变量名 []; 例如: int [] age; double [] score; String names []; Person persons[]; 申明的时候不能提供长度(实际创建对象的时候提供): int [5] age;//非法 创建数组的方式: a.使用 new 在堆中开辟内存空间; b.直接使用 {}给的初始值 例如:int [] age = new int[长度]; //所有元素使用都是默认值 int [] age = {20,30,40,50}; //创建长度为4，并且赋值了的数组 4.数组元素的引用方式：数组名[数组元素下标] age[1] ==>30 数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i]; 数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 - (n-1)； 如int a[]=new int[3]; 可引用的数组元素为a[0]、a[1]、a[2] 数组提供：length 指明它的长度 例如：a.length 指明数组 a 的长度(元素个数) 5.案例 for (int i = 0; i powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day06/day06.html":{"url":"content/day06/day06.html","title":"第六章:类和对象","keywords":"","body":" 一、回顾 二、类和对象 1.为什么使用面向对象 2.类的基本概念 3.类图 4.类的语法格式 5.属性的基本语法 6.方法的基本语法 三、对象 3.1 类的访问机制 3.2 匿名对象 day06_类和对象 一、回顾 1.坏境搭建,基本命令使用 2.关键字，标识符，变量，数据类型，运算符 3.分支语句 if...else switch...case 4.循环语句 for,while,do...while break: 跳出最近的循环 continue:跳出当前循环，继续执行下一次循环 5.数组 a.基本概念 存放单个类型的多个数据，大小一旦创建不能改变;元素默认初始化 b.数组的创建 type [] 变量 = new type[长度]; type 变量 [] = new type[长度]; type 变量 [] = {元素1,元素2,元素3...}; 例如:int [] age = new int [10]; c.获取数组元素的方式 通过下标获取:下标从0开始,到length-1。 语法: 数组[下标] 例如:int age [] = {10,20,40,70,50} age[2]====>40 age[0]====>10 age[5]=====>下标越界 d.给数组赋值，使用下标的方式 age[2]= 80;===>原来下标为2，也就第三个元素 40变成80 e.使用for循环，获取数组中所有的元素 for(int i = 0;i 主要内容: ​ 类和对象 ​ u理解面向对象的概念 ​ u类的定义 ​ u声明类、属性、方法 ​ u创建、使用对象 ​ u对象的生命周期 ​ u匿名对象 ​ 二、类和对象 1.为什么使用面向对象 1.现实世界都是由对象组成 2.软件出现的目的: a.使用计算机的语言来描述现实世界 b.使用软件解决现实生活中的问题 网购: 淘宝:C2C， 天猫:B2C 2.类的基本概念 1.类是对象的抽象 2.类是一组具有相同属性和行为的集合。 3.类是对象的模板.可以根据模板创建任意多个对象 创建类分为三步: a.发现具体的类型: 根据对象------>抽象---->类 Dog 类的关键字:class b.发生类的属性：不同的类，拥有多个属性。 属性的定义:理解为全局变量 (定义在类中，方法的外部) c.发生类的行为(方法,函数): 一个方法，看出是一个功能。例如:自我介绍,吃,睡,跑.... //创建了一个狗类 public class Dog { // 发现狗类的属性 String name = \"旺财\"; int health = 100;// 健康度 int love = 100;// 亲密度 String strain = \"泰迪\"; // 品种 // ...放自己需要|关注的属性 // 行为 方法 方法的四要素: public void show() { // 自我介绍 System.out.println(\"hello 我叫:\" + name + \" 种类:\" + strain + \" 健康度:\" + health + \" 和主人的关系:\" + love); } public void eat() { System.out.println(\"天天吃骨头...\"); } public void sleep() { System.out.println(\"睡眠时间，请勿打扰.....\"); } } 3.类图 4.类的语法格式 语法格式： [] class { [] [] [] } 说明：修饰符public：类可以被任意访问 类的正文要用{ }括起来 //例如 public class Person{ //属性申明 String name; int age; String sex; //使用默认无参数的构造器 //方法 public void eat(){ System.out.println(\"红烧大猪头！！！\"); } } 5.属性的基本语法 语法格式(全局变量)： [] 类型 [=初值] ; public String name = \"张三\"; private int age = 20; 说明：修饰符 private: 该属性只能由该类的方法访问。 修饰符 public: 该属性可以被该类以外的方法访问。 类型：任何基本类型，如int、boolean或任何类。引用类型也可以 6.方法的基本语法 语法格式： ([]) { [] } 方法的四要素: a.返回类型 b.方法名称 c.参数列表 d.方法体 {}之间的内容 1.返回值类型 a.可以返回任意类型的数据,int，long,char,byte,String ..所有类型 b.如果没有需要返回的值: 使用 void c.如果有返回值，需要在方法体中，进行返回: return 语句传递返回值; d.如果有返回值，方法使用的时候，才可以使用变量进行接收 2.方法名称 符号方法的命名规则即可。 3.参数的列表 a.形参列表 i:在方法定义的时候，指定的参数 ii:形式参数必须有具体的类型 iii:局部变量，作用域在{}方法体内部使用 /** * num1，num2 称为形式参数 。具体内容,取决于调用该方法时候传递进来的实参(实际参数) * @param num1 * @param num2 * @return */ public int add3(int num1, int num2) { int sum = num1 + num2; return sum; } b.实参列表 i:在方法调用的时候传递的参数 ii:参数对应的类型，个数，顺序 必须和形参一致; // 230:对应第一个形参 100:对应第二个形参 ...依次类推 int sum = mathUtil.add3(230, 100); System.out.println(\"sum:\" + sum); 4.方法体: {}之内的都是方法体的内容 {}也是具体处理业务逻辑的地方 /** * 第一个数的10倍，第二个数的5倍 相加 * * @param num1 * @param num2 * @return */ public int add4(int num1, int num2) { //方法体 ：处理具体的业务逻辑 int sum = num1 * 10 + num2 * 5; return sum; } } 三、对象 1.对象 a.对象是类的实例化，类的具体体现形式; b.万物皆对象 2.先有类还是先有对象 a.从设计角度 先有对象,将对象抽象成一个类; b.从代码角度 先有类，通过 new+类 创建具体的对象 3.创建对象的语法 new + 构造方法() : 例如: new Dog(); new Person(); 特殊的方法： a.不需要返回值 b.方法名和类名一致; 对象的使用: 调用对象里面的属性和方法 对象名.属性名 对象名.方法名 Dog dog = new Dog(); dog.name dog.eat() 如果创建了一个类的多个对象，对于类中定义的属性，每个对象都拥有各自的一套副本，且互不干扰。 一旦对象创建成功，对象之间互不干涉。一个类可以创建任意多个对象。 3.1 类的访问机制 在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。（有一个例外） 在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。 3.2 匿名对象 我们也可以不定义对象的引用，而直接调用这个对象的方法。这样的对象叫做匿名对象， 如：new Person().shout(); 如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。 我们经常将匿名对象作为实参传递给一个函数调用。 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day07/day07.html":{"url":"content/day07/day07.html","title":"第七章:封装","keywords":"","body":" 一、回顾 二、封装和隐藏 2.1 访问修饰符 2.2 构造方法 2.3 方法的重载 2.4 可变参数 2.5 构造方法重载 2.6 this 2.7 package 2.8 import语句 day07封装 一、回顾 1.类和对象 2.类的概念 具有一组相同属性和行为的集合; 类是对象的抽象;修饰类的关键字 class 3.发现类 a.根据实际事物抽象出类 b.找出类的特征(属性),值关注自己需要的属性; c.找出共同的行为 4.属性 成员变量,全局变量都表示属性。定义: [修饰符] 数据类型 属性名 = [初始值]; 5.方法|行为|函数 方法可以理解为具有特定功能的一个小代码块。 定义方法的格式: [修饰符] 返回值 方法名([形参列表]){//方法体 [return 具体值]} 方法的四要素: a.返回值 i:如果方法没有返回值 使用void修饰 ii:有返回值返回具体的类型,需要在方法的内部使用 return 关键字 iii:有返回值的方法，调用的时候 可以使用变量接收。 b.方法名 i:符号标识符命名规则。 c.形参列表 i:形参列表 可以同时拥有多个参数 ii:参数的作用域 只在该方法体中有效 d.方法体 i:具体的功能 ii:建议不超过 100行数据 6.构造方法|构造器 7.对象 a.万物皆对象 b.对象是实实在在的事物 c.对象是类的实例化，也是类的具体体现形式 创建对象: 类名 obj = new +类名(); 对象调用属性和方法 obj.属性 obj.方法 6.类的访问机制 a.在同一个类中访问 普通方法之间可以进行相互调用，可以不用使用对象.(内置的this) (同等级别:静态的|普通的) b.在不同的类中访问 先创建对象，通过对象 obj.属性 obj.方法名 构造方法|构造器 1.作用 a.用来初始化(创建)对象 b.按照指定的方式来创建 2.特点 a.默认拥有一个无参的构造方法 b.如果定义了有参构造方法，那么默认的无参构造就会消失。如果需要得自己重新定义 c.构造方法 没有返回值，也不用使用void修饰。方法名和类名相同 d.构造方法不能使用 void修饰，如果修饰就会变成普通方法 3.和普通的区别(什么时候使用构造，什么时候使用普通方法) 主要内容:面向对象的特性---封装 二、封装和隐藏 1.概述 a.封装 隐藏内部实现细节，对外提供一个统一访问的接口 b.隐藏 就是private修饰，除了自己 别人无法访问。 2.作用 隐藏一个类的实现细节； 使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑，限制对属性的不合理操作； 便于修改，增强代码的可维护性； 2.1 访问修饰符 访问修饰符 private 默认(default) protected public 本类 可以 可以 可以 可以 同包 不 可以 可以 可以 子类 不 不 可以 可以 整个项目 不 不 不 可以 2.2 构造方法 1.特征 它具有与类相同的名称； 它不含返回值； 注意：在构造方法里不含返回值的概念是不同于“void”的，在定义构造方法时加了“void”，结果这个方法就 不再被自动调了。 一个类中可以拥有多个构造方法 2.作用 当一个类的实例对象刚产生时，这个类的构造方法就会被自动调用，我们可以在这个方法中加入要完成初始化工作 的代码 按照指定的规则来创建对象,完成对象的初始化工资;(给所有的属性赋值) 注意: 构造方法不能使用void修饰，否则就是普通方法。丧失了构造方法的作用 构造方法通过new 关键字 调用。不能通过对象调用 : new Person(); //调用Person无参构造 new User(\"zhangsan\", \"深圳华美居\", \"110\")； //调用有参数构造 3.构造方法注意 a.Java语言中，每个类都至少有一个构造方法； b.如果类的定义者没有显式的定义任何构造方法，系统将自动提供一个默认的构造方法： 默认构造方法没有参数 默认构造方法没有方法体 默认的构造方法：Animal(){} 所以：不编写构造方法就能用new Xxx()创建类的实例。 c.Java类中，一旦类的定义者显式定义了一个或多个构造方法，系统将不再提供默认的构造方法； 构造器的主要作用：利用构造器参数初始化对象的属性。 2.3 方法的重载 方法的重载: 在同一个类中同名不同参数的方法，称之为方法的重载; 满足重载的条件 a.方法的形参列表，必须不同(参数的个数,参数的类型,参数的顺序至少有一个不一样) b.多个方法的返回值可以相同，也可以不相同 c.调用重载方法的时候，具体调用哪一个方法，取决于 传入的实参的数据类型。 2.4 可变参数 1.形参列表是动态可变的。根据实参的个数 2.5 构造方法重载 语法和普通方法一样。在调用的时候 使用 new 构造方法(实参) 2.6 this 1.this 表示当前对象的意思 2.没有被static修饰的方法，都可以直接使用this 3.this可以调用当前类的成员变量，成员方法，构造方法 a.this调用成员变量 调用属性 this.name b.this调用成员方法 this.getAge(); c.this调用构造方法 i:构造方法与构造方法之间可以调用 ii:必须写在构造方法的第一行 public class Person { private String name; private int age; private Date birthDate; // 日期 public Person(String name, int age, Date d) { this.name = name; this.age = age; this.birthDate = d; } public Person(String name, int age) { this(name, age, new Date()); // this.name=name; this.age=age; // this.birthDate=null; } public Person(String name, Date d) { this(name, 30, d); // this.name=name; this.age = 30; this.birthDate = d; } public Person(String name) { this(name, 30); // this.name=name; this.age=30; } public void show() { System.out.println(\"name:\" + name + \" age:\" + age + \" birthDate:\" + birthDate); } } 2.7 package package com.hzit07; // 定义包 如果不写 就是默认包 用‘ .’ 来指明包(目录)的层次 com.hzit.xxx 2.8 import语句 如果是同一个包下，可以不用import。 如果是不同包下，可以使用import引入包 import 包名[.子包名…]. import java.util.*; //不推荐 import java.util.Scanner; // powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day08/day08.html":{"url":"content/day08/day08.html","title":"第八章:继承","keywords":"","body":" 一、回顾 二、继承 2.1 方法的重写（覆盖） 2.2 super day08笔记_封装 一、回顾 1.封装与隐藏 封装：隐藏内部实现细节，对对外提供统一访问的接口; 具体表现: a.就属性进行私有化,提供get/set方法进行访问; b.具体的方法(函数)进行封装。封装一个 计算工资的方法。 2.访问修饰符 private:私有的 本类 default(无修饰符):默认的 本类 本包 protected:受保护的 本类 本包 子类 public:公共的 本项目中任何的地方 3.get/set方法 看成普通方法,作用:get 用来提供数据 set:用来设置数据 方法名规范: get属性名() getName(); set属性名() setName(); public String getName(){ return name; } public void setName(String name){ this.name = name; } 4.构造方法 a.特点 i:方法的名称和类名一致; ii:放方法没有返回值，也不需要使用void修饰。如果使用void变成了普通方法 b.作用 创建对象，并且对对象进行初始化操作(给属性赋值) c.注意 a.每个类都至少一个构造方法; b.默认都是有一个无参的构造方法; c.如果定义有其他有参的构造方法，那么无参的构造就会自动消失。如果需要自己显示定义 d.构造方法也可以重载。 d.构造方法的调用 是使用 new + 构造方法([参数]); 无法使用 obj.构造方法(不支持) public Person(){ } public Person(String name){ } 5.方法的重载 同名不同参的方法，称为方法的重载; 语法: a.参数的顺序、个数、类型至少有一个不一样; b.返回值可以相同，也可以不同 多个方法如何调用: a.通过传递的实参类型，顺序，及个数来决定调用哪一个方法。如果都不符合,语法会报错; 可变参数: 定义方法的时候，在形参列表中 使用 ... 可变参数 必须放在形参列表的最后一个参数位 6.package和import package:创建包 可以使用 . 进行目录的分层; import:导入其他包中需要使用的类 二、继承 1.基本概念 子类自动享有父类中所有非私有的属性和方法。子类可以对父类进行扩充。 2.继承的优点 a.提高代码的可重用性及扩展性; b.设计应用程序变得更加简单; c.可以轻松的自定义子类;公共的属性和方法交给父类统一处理; 3.继承的语法 a.关键字 : extends b.语法结构 [修饰符] class 类名 [extends 父类]{} //定义父类：将公共的属性和方法，放入父类中，让子类自动继承 public class Person { public String name; public int age; public Date birthDate; public String sex; } public class Student extends Person { public String school; //继承父类属性之外，自己定义的属性 public void getInfo() { System.out.println( \"name:\" + name + \" age:\" + age + \" birthDate:\" + birthDate + \" school:\" + school + \" sex:\" + sex); } } 4.java继承的特点 a.java只支持单继承,一个子类只能有一个直接的父类; b.一个父类可以同时派生出多个子类 5.总结 子类继承了父类，就继承了父类的方法和属性。 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 因而，子类通常比父类的功能更多。 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。 6.子类不能继承父类的内容: a.被private修饰的属性和方法 b.不同包中，使用默认修饰符修饰的属性和方法 c.构造方法不能被继承 7.多重继承的执行顺序 父类的属性---->父类的构造方法---->子类的属性----->子类的构造方法 8.成员变量的隐藏 当子类中定义的成员变量只要和父类中的成员变量同名时，子类就隐藏了继承的成员变量 2.1 方法的重写（覆盖） override(重写)和overload(重载)的区别 1.概念 a.在子类中可以根据需要对从父类中继承来的方法进行改造—覆盖方法(方法的重置、重写)，在程序执行时，子类 的方法将覆盖父类的方法。 b.覆盖方法必须和被覆盖方法具有相同的方法名称、参数列表和返回值类型。 注意:返回值类型,除了本身的类型之外，也支持子类的类型 c.覆盖方法不能使用比被覆盖方法更严格的访问权限。 可以使用 @Override 注解 判断是否是重写方法 @Override //如果不是重写方法，出现错误 public void show() { System.out.println(\"son....show\"); } 2.重写和重载的区别 a.重载同名不同参，至少有一个参数不一样。重写同名同参。所有的参数必须一样 b.重载的返回值可以一样，也可以不一样。重写必须一样 c.重写的访问修饰符号不能比被重写的权限更低 d.重载可以在一个类中，也可以在父子类。重写必须子类重写父类的方法。 2.2 super 在Java类中使用super来引用父类的成分 super可用于访问父类中定义的属性 ---->super.name super可用于调用父类中定义的成员方法 ---->super.findArea() super可用于在子类构造方法中调用父类的构造方法 super的追溯不仅限于直接父类 调用构造方法: a.在子类的构造方法中可使用super(参数列表)语句调用父类的构造方法 b.如果子类构造方法中既未显式调用父类构造方法，而父类中又没有无参的构造方法，则编译出错 c.如果子类的构造方法中没有显示地调用父类构造方法，也没有使用this关键字调用重载的其它构造方法，则系统 默认调用父类无参数的构造方法 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day09/day09.html":{"url":"content/day09/day09.html","title":"第九章:多态","keywords":"","body":" 一、回顾 二、多态 2.1 数据转换 2.2 Object 三、抽象类 四、接口 五、关键字 5.1 final 5.2 static day09_多态 一、回顾 1.继承 概念:子类继承父类的所有非私有属性和方法。 优点: a.提高代码的重用性; b.简化代码操作 c.更简单的完成子类操作 关键字:extends 语法结构:[修饰符] class 类名 extends 父类名{} 特点: a.java类属于单继承的，一个类只能有一个直接父类。一个父类可以派生出多个子类。 b.Object是所有类的父类 那些东西不能被子类继承: a.被private修饰的属性和方法 不能被继承 b.不同包中被默认的修饰符修饰(缺省)的属性和方法，不能被继承 c.构造方法不能被继承 2.方法的重写 a.方法的名称，参数，返回值保持一致; b.重写的方法的访问修饰符不能比被重写的方法修饰符权限更低 c.子类重写父类的方法(父类的父类) 3.super 表示父类的对象 a.可以调用父类的成员属性 super.属性 b.可以调用父类的成员方法 super.方法() c.调用父类的构造方法 在所有的子类的构造方法中默认 调用父类无参的构造。也可以自己指定调用父类的有参构造。 super()调用父类的构造方法,不能和this()同时出现 。也只能在子类的构造方法中使用 对象的初始化过程: 父类的属性---->父类的构造方法---->子类的属性------>子类的构造方法 二、多态 1.概念 同一个事物具有多种不同的表现形态。 2.特点 a.在java中，子类对象可以替代父类对象使用(父类的引用指向子类的对象)Person p = new Student(); b.一个变量同一时刻 只能有一个确定的数据类型 c.一个引用类型变量可能指向(引用)多种不同类型的对象 Person p = new Student(); //List list = new ArrayList(); Object o = new Person();//Object类型的变量o，指向Person类型的对象 o = new Student(); //Object类型的变量o，指向Student类型的对象 d.一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属 性和方法 编译的时候，看变量的类型。运行的时候看的是具体的对象。 3.方法的动态绑定 在运行时候根据具体的对象，动态的绑定需要运行的方法。 4.多态的体现 a.重载 :方法名一样，参数不同 b.重写 :方法名和参数保持一致; c.父类的引用指向子类的对象(重写) 2.1 数据转换 数据转换:必须存在关系才能转换。（继承） 子类转父类---->自动类型转换 Person person = new Student(); 父类转子类---->强制转换 Student student = (Student)person(); instanceof: 作用:用来判断对象是否是属于某一个类的对象 x instanceof A 注意: 判断的对象和类存在子父类关系，否则编译出错 健壮性: 注意 a.从子类到父类的类型转换可以自动进行 b.从父类到子类的类型转换必须通过造型(强制类型转换)实现 c.无继承关系的引用类型间的转换是非法的 d.在造型前可以使用instanceof操作符测试一个对象的类型 package com.hzit01; public class Test02 { /** * 让所有的人进行自我介绍 * * @param person */ public void method(Object person) { // 一个父类 对应有多个子类 强转之前应该判断 if (person instanceof Student) { // instanceof:判断某个对象 是否是属于某个类型 。作用：避免出现转为类型一次 Student--->Offices //非法 Student student = (Student) person; student.getInfo(); student.study(); } if (person instanceof Offices) { Offices offices = (Offices) person; offices.getInfo(); offices.work(); } if (person instanceof Person) {//false Person p = (Person) person; p.getInfo(); } } public static void main(String[] args) { Test02 test02 = new Test02(); Person person = new Offices(); test02.method(\"xxx\"); } } 2.2 Object 1.概述 a.Object是所有类的父类（超类|基类） b.如果类没有使用extends继承自己的类，那么默认继续 Object c.所有的类都会自动享用Object中所有的属性和方法。 2.常用的方法(参照帮助文档API) a.hashCode() 用户对象的hash码地址。就是一串数字 \"A\":65 \"a\":97 b.toString() 返回该对象的字符串表示; 对象的组成:getClass().getName() + \"@\" + Integer.toHexString(hashCode()); 对象打印的时候会自动的调用toString()方法; 重写toString(): c.equals() i:Object对象中的方法，默认比较的也是内存地址; ii:特例:String,Date,File包装类(基本类型对应的包装类)比较的是内容是否相等，而不是地址 原因:默认重写了equals方法。 d.== 全等于 i:如果是基本类型的数据，比较的是内容 ii:引用数据类型比较的就是内存地址是否相同 == 和 equals方法之间的区别: a.==可以比较基本类型也可以比较引用类型 b.==和equals都是比较的引用地址，但是可以重写equals比较内容 c.String,Date,File,包装类默认equals比较是内容，而不是地址 //重写toString public class Person extends Object { String name = \"张三\"; int age = 20; public void getInfo() { System.out.println(\"PersonInfo.....name:\" + name + \" age:\" + age); } @Override public String toString() { return \"Person [name:\" + name + \" age:\" + age + \" ]\"; } // 重写equals方法 @Override public boolean equals(Object obj) { if (this == obj) { // 表示地址一致，肯定是同一个对象 return true; } if (obj instanceof Person) { // 传入的对象是相同的 Person person = (Person) obj; // 传入对对象 // 比较条件 名称和age都是相同才返回true if (this.name.equals(person.name) && this.age == person.age) { return true; } return false; } else { // 传入的对象和比较的对象 不是同一个类型 不用比 return false; } } } //测试 public static void main(String[] args) { Person person = new Person(); System.out.println(person); //默认调用toString() System.out.println(person.toString()); // 调用就是子类重写父类的toString() Person p1 = new Person(\"张三\", 20); Person p2 = new Person(\"张三\", 20); Person p3 = new Person(\"李四\", 20); System.out.println(p1.equals(p2)); //true System.out.println(p1.equals(p3)); //false } //Person [name:张三 age:20 ] //Person [name:张三 age:20 ] //true //false 三、抽象类 1.概念 在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果 一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。 通俗:定义没有方法体的方法。员工只知道要工作，不知道具体的工作。 2.关键字 abstract修饰 3.抽象类 被abstrac修饰的类，称为抽象类。 4.抽象方法 被abstrac修饰的方法，称为抽象方法。 5.特点 a.抽象类可以包含抽象方法，也可以包含普通方法. b.抽象方法所在的类，必须是抽象类。抽象类并不一定需要抽象方法 c.子类可以继承抽象类，子类必须实现抽象类中的抽象方法，或者将该子类也变成抽象类 总结: 1.多态 a.子类的对象可以代替父类的对象使用（父类的引用指向子类的对象）; b.同一时刻，一个变量只属于一个数据类型 c.同一变量，可以指向不同的对象 体现形式: 方法的重写:同名同参 方法的重载:同名不同参 2.数据类型的转换 a.自动转换 从小到大 b.强制转换 从大到小 注意:引用类型强制转换的时候，必须存在父类(接口)关系。否则编译出错。 可以使用instanceof 关键字进行判断; instanceof:判断某个对象是否是属于某个类型。 person instanceof Student 3.Object a.Object是所有类型的父类,超类，基类，根类 b.没有使用 extends 关键字的时候，隐式的使用 extends Object c.Object主要的方法: hashCode(): 返回对象的hash码地址 toString(): 返回对象的字符串格式 this.getClass.getName()+\"@\"+Integer.xxx(hashCode()); 重写toString()返回自己关注的信息 equals():比较对象的引用地址是否相同。作用和 == 一样。 return (this==obj); 特例:String,Date,File包装类 他们的equals比较的就是具体的内容，而不是地址 因为这些重写了Object.equals()方法 如果需要，自己也重写equals方法。 4.抽象类 a.使用abstract修饰的类称为抽象类 b.使用abstract修饰的方法称为抽象方法，抽象方法不能有方法体。 注意: a.抽象类中可以有抽象方法，也可以有普通方法 b.抽象类中可以没有抽象方法，都是由抽象的方法的类，一定是抽象类 c.子类继承抽象的时候，必须实现所有的抽象方法，或者将该子类变成抽象类 四、接口 1.概述 接口是一个特殊的抽象类。接口中的所有方法都是抽象方法，所有的变量 都是静态常量； 接口弥补了抽象类单一继承的不足； 接口同样可以继承接口，并且可以实现多继承； 2.关键字 定义接口:interface 实现接口:implements 语法:class 类 implements 接口名,接口名2{ //实现所有的抽象方法} 3.接口的特性 a.接口不可以被实例化(必须有实现类) b.实现类必须实现接口中的所有方法。（接口中的方法都是抽象方法） c.实现类可以实现多个接口。接口与接口之间可以实现多继承 d.接口中的所有变量都是静态常量 c.接口看出一种能力，而不用关系具体是谁有这种能力。 4.接口和抽象类的区别 a.接口是interface,抽象类 class。java类继承抽象类，实现接口 b.接口是一个特殊的抽象类。接口中的所有方法都是抽象方法，抽象类中也可以拥有普通方法 c.类单继承抽象类，类多实现接口。接口多继承接口 d.接口中定义的属性必须是public，static，final类型的常量，而抽象类没有限制 5.接口的多态写法 Paper paper = new A4(); Paper paper = new B5(); 五、关键字 this:当前对象 super:当前的父类对象 final:最终的,不可改变的 static:静态的 5.1 final final可以修饰： a.final修饰变量:常量 b.final修饰方法:不能被重写 c.final可以修饰类:不能被继承 常量: a.使用final修饰的变量，叫做常量 b.常量在定义的时候必须赋值,一旦赋值不可更改 c.常量的命名规则都是大写，多个单词使用_下划线 XXX_ZZZ_YYY final修饰的方法，最终方法,该方法不能被重写: public final void sayHello() { System.out.println(\"hello，大家好我是:\" + name); } final修饰类，表示类不能被继承： public final class Person { private String name = \"zhangsan\"; public final void sayHello() { System.out.println(\"hello，大家好我是:\" + name); } public void method() { } } String能不能被继承: 不能，因为String类是被final修饰的。不能被其他类继承。 5.2 static 静态的: 静态变量:也可以使用类名.变量 静态方法: a.对象可以调用普通方法，也可以调用静态方法。 b.静态方法属于类级别，所以可以不用对象，直接使用类调用 类名.方法() |类名.属性() 静态代码块： 静态的表示是属于类级别的。不需要对象可以直接使用。初始化过程在类加载的就已经完成。 public class Emp { String name = \"张三\"; public Emp() { System.out.println(\"emp无参构造\" + name); } // 代码块 { System.out.println(\"普通代码块:\" + name); } // 静态代码块 static { System.out.println(\"静态代码块...\"); } } public class Son extends Emp { public Son() { System.out.println(\"son构造方法\"); } // 初始化功能 { System.out.println(\"son代码块\"); } // 加载统一的配置文件 static { System.out.println(\"son静态代码块\"); } } public class Test02 { public static void main(String[] args) { new Son(); } } //静态代码块... //son静态代码块 //普通代码块:张三 //emp无参构造张三 //son代码块 //son构造方法 接口中所有的变量都是静态常量：自动的添加public static final 面向对象: 作用:怎么去创建自己的对象。 高级部分: 怎么去使用java提供好的对象。List,Map,IO,网络编程,多线程.... powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day10/day10.html":{"url":"content/day10/day10.html","title":"第十章:常用的类和对象","keywords":"","body":" 一、API的使用 二、包装类的使用 三、String 四、StringBuffer 五、StringBuilder 六、Math 七、Random 八、Date-- java.util.Date 8.1 DateFormat 8.2Calendar day10_常用的类和对象 回顾: 接口的使用: 定义接口:interface 实现接口:implements 类可以多实现接口,接口可以多继承接口: class 类名 implements 接口名,接口名2{} interface 接口名 extends 父接口,父接口2{} 接口和抽象类的区别: final: 最终的 final修饰变量:常量 final修饰方法:表示该方法不能被重写 final修饰类:表示类不能被继承 static:静态的 属于类级别,可以直接使用类名.方法名() 类名.属性名 Person.getName(); Person.name; 面向对象：怎么创建对象，对象的语法结构 如何使用java，提供给我们的类 1.主要的内容 a.API的使用 b.包装类 c.String 一、API的使用 java官方提供的帮助文件。 java常用的五大包 java.lang:语言包(java的默认包) String,Object,包装类 java.io:操作IO流及文件相关的包 File FileInputStream... java.util:工具包 Arrays,Scanner,List... java.net:网络包 Socket,ServerSocket... java.sql:数据库相关的包 Connection,ResultSet, java.text:格式化操作 查询帮助文档: a.查找类，两种方式；索引(索引),根据包的路径名 主要内容: 二、包装类的使用 包装类就是可以直接将简单类型的变量表示为一个类。 除了 int和char之外，所有的包装类就是将基本类型的首字母大写 JDK1.5之后实现自动的拆箱和封箱 装箱：从基本类型转换为包装类 拆箱:从包装类转换为基本类型 包装是引用类型的数据 包装类常用的方法: 三、String 1.概念 String 类代表字符串;使用\"\"表示String 类型的值; 字符串是常量；它们的值在创建之后不能更改; 2.String常用的构造方法 String构造方法 简介 String() 创建一个新的字符串，但是值为空 String(byte [] bytes) 根据byte数据创建String,编码使用平台默认 String(byte[] bytes,String charsetName); 根据byte数据创建String，使用指定的编码方式 String(byte[] bytes, int offset, int length, String charsetName) 根据byte数据创建String，规定长度和指定编码方式 String(char [] ch) 根据字符数组创建对象,使用默认编码 String(char [] ch,String charsetName) 根据字符数组创建对象,使用指定的编码方式 public static void main(String[] args) throws Exception { // 将字符串转为数组(字符数组，字节数组) String str = \"abcdefghigkl\"; byte[] bytes = str.getBytes(); for (byte b : bytes) { System.out.println(b); } // 将字节数组 变为String String string = new String(bytes); System.out.println(string); String string2 = new String(bytes, \"UTF-8\"); System.out.println(string2); String string3 = new String(bytes, 4, 5); // 指定需要截取的范围 String string4 = new String(bytes, 2, 5, \"UTF-8\"); System.out.println(string3); System.out.println(string4); } 3.常用的方法 public static void main(String[] args) throws Exception { String str = \"Hello World hello java我\"; System.out.println(\"获取字符串的长度:\" + str.length()); System.out.println(\"equals:\" + str.equals(\"hello\")); String lowerCase = str.toLowerCase(); String upperCase = str.toUpperCase(); System.out.println(\"转换为小写:\" + lowerCase + \"---->\" + str); System.out.println(\"转换为大写:\" + upperCase + \"---->\" + str); char ch = str.charAt(4);// 根据下标获取指定字符 从0开始计算 System.out.println(ch); // 能找到返回值具体位置，否则返回-1.表示没有该字符 int indexOf = str.indexOf(\"o\"); // 指定字符 第一次出现的问题 从0开始计算 System.out.println(\"第一次出的位置:\" + indexOf); int indexOf2 = str.indexOf(\"o\", 5); // 从指定位置找，下标还是从0开始计算 System.out.println(\"从第五个位置开始计算:\" + indexOf2); int lastIndexOf = str.lastIndexOf(\"o\"); System.out.println(\"最后一个出现的位置:\" + lastIndexOf); int lastIndexOf2 = str.lastIndexOf(\"o\", 5); System.out.println(\"最后一个出现的位置:\" + lastIndexOf2); String substring = str.substring(1); System.out.println(\"截取:\" + substring); String substring2 = str.substring(1, 3); // 包括前面，不包括后面的下标 1 2 顾前不顾尾 System.out.println(\"截取:\" + substring2); String[] split = str.split(\"o\"); for (String s : split) { System.out.println(s); } System.out.println(\"是否相等:\" + (\"a\".compareTo(\"b\"))); System.out.println(\"是否包括:\" + (str.contains(\"a\"))); System.out.println(\"是否是java结尾:\" + (str.endsWith(\"java\"))); System.out.println(\"是否是java开始:\" + (str.startsWith(\"java\"))); // 提供两个获取数组的方法 （字符串数组，字节数组） byte[] bytes = str.getBytes(\"utf-8\"); for (byte b : bytes) { System.out.println(\"字节:\" + b); } char[] charArray = str.toCharArray(); for (char c : charArray) { System.out.println(\"字符:\" + c); } String string = new String(bytes, \"utf-8\"); String string2 = new String(charArray); System.out.println(string); System.out.println(string2); System.out.println(str.replace(\"a\", \"AAAA\"));//替换 } 四、StringBuffer 1.概述 StringBuffer线程安全的字符串缓冲区; StringBuffer是一个内容可变的字符串;(String是内容不可变) 2.构造方法 StringBuffer() :创建一个空的字符串缓冲区，初始容量为16个字符 StringBuffer(String str):构造一个字符串缓冲区，并将其内容初始化为指定的字符串内容。 3.常用方法 toString():转换为String charAt(): indexOf(): length(): replace(): subString(): append():追加内容 reverse():倒序，反转。将内容反转 insert():插入 delete(): 删除指定区域的数据 deleteCharAt():删除指定位置的值 public static void main(String[] args) { StringBuffer sbf = new StringBuffer(); StringBuffer stringBuffer = new StringBuffer(\"hello\"); System.out.println(sbf.toString()); System.out.println(stringBuffer.toString()); // 和String一样的方法 char charAt = stringBuffer.charAt(1); System.out.println(charAt); // 自己新增的方法 stringBuffer.append(\"world\").append(\"hello java\"); // 追加字符串 System.out.println(stringBuffer); stringBuffer.reverse(); // 反转 整个StringBuffer进行了反转 System.out.println(stringBuffer); stringBuffer.insert(4, \"xxxxxx\"); //向指定位置添加值 System.out.println(stringBuffer); stringBuffer.delete(4, 10); // 删除指定区域的数据 System.out.println(stringBuffer); stringBuffer.deleteCharAt(0); // 删除指定位置的值 System.out.println(stringBuffer); } 五、StringBuilder 使用方法和StringBuffer一样。 StringBuffer是同步的，线程安全的。效率相对低 StringBuilder是线程不安全，效率高; String,StringBuffer,StringBuilder之间的区别: a.String是内容不可变得,后者内容是可变的 b.String,StringBuffer是线程安全的，StringBuilder是线程不安全的 六、Math 和数学相关的对象 常用方法: 方法 说明 int abs() 返回输入参数的绝对值 double cbrt() 返回输入double参数值得立方根 double ceil() 返回大于或等于参数的最小double值 \\ 取大 double floor() 返回最大值double值 \\ 取小 double max() 返回两个值，参数较大的一个 double min() 返回两个值，参数较小的一个 double random() 返回一个0.0到1.0之间的随机数 int round() 返回最接近输入数的int值 public static void main(String[] args) { System.out.println(\"绝对值:\" + Math.abs(-0)); System.out.println(\"立方根:\" + Math.cbrt(4)); System.out.println(\"向上取整:\" + Math.ceil(10.01)); System.out.println(\"向上取整:\" + Math.ceil(10.5)); System.out.println(\"向上取整:\" + Math.ceil(10.9)); System.out.println(\"向下取整:\" + Math.floor(10.01)); System.out.println(\"向下取整:\" + Math.floor(10.5)); System.out.println(\"向下取整:\" + Math.floor(10.9)); System.out.println(\"四舍五入:\" + Math.round(10.01)); System.out.println(\"四舍五入:\" + Math.round(10.5)); System.out.println(\"四舍五入:\" + Math.round(10.9)); System.out.println(\"最大:\" + Math.max(20.02, 20.01)); System.out.println(\"最小:\" + Math.min(20.02, 20.01)); // 随机生成 1-33 int random = (int) (Math.random() * 33) + 1; // while (true) { // int random = (int) (Math.random() * 33) + 1; // // System.out.println(random); // if (random 33) { // break; // } // // } // while (true) { // double random = Math.random(); // System.out.println(\"随机数(大于等于0小于1)\" + random); // if (random == 0) { // break; // } // } } 七、Random Random类提供了产生各种类型随机数的方法 Math中的random方法只能产生double类型的随机数 Random只有一个无参的构造方法，创建方式如下：Random rd = new Random(); 方法 说明 int nextInt() 产生一个整形随机数 int nextInt(int n) 产生一个0~n的随机整数值，包括0，但不包括n double nextDouble() 产生一个0.0~1.0的double型随机数 float nextFloat() 产生一个0.0~1.0的float型随机数 long nextLong() 产生一个long型随机数 public static void main(String[] args) { Random random = new Random(); System.out.println(\"随机整数:\" + random.nextInt()); System.out.println(\"随机整数:\" + random.nextInt(33)); // 0-32 :不包括33 [0-32] System.out.println(\"double：\" + random.nextDouble()); System.out.println(\"boolean:\" + random.nextBoolean()); // while (true) { // System.out.println(\"随机整数:\" + random.nextInt(33)); // 0-32 :不包括33 [0-32] // } } 八、Date--> java.util.Date 类 Date 表示特定的瞬间，精确到毫秒。 1s = 1000毫秒 1.构造方法 new Date():获取当前系统时间 new Date(long date):获取指定的时间,从1970,1,1开始计算。0表示 2.普通方法 getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。 public static void main(String[] args) throws Exception { // 1.系统时间 // while (true) { // Thread.sleep(1000); // 睡一秒 Date date = new Date(); System.out.println(date); long time = date.getTime(); // 毫秒数 System.out.println(time); Date date2 = new Date(time); // 根据毫秒数获取时间 System.out.println(date2); // } } 8.1 DateFormat DateFormat 是日期/时间格式化子类的抽象类,使用的是子类:SimpleDateFormat 字母 日期或时间元素 表示 示例 G Era 标志符 Text AD y 年 Year 1996; 96 M 年中的月份 Month July; Jul; 07 w 年中的周数 Number 27 W 月份中的周数 Number 2 D 年中的天数 Number 189 d 月份中的天数 Number 10 F 月份中的星期 Number 2 E 星期中的天数 Text Tuesday; Tue a Am/pm 标记 Text PM H 一天中的小时数（0-23） Number 0 k 一天中的小时数（1-24） Number 24 K am/pm 中的小时数（0-11） Number 0 h am/pm 中的小时数（1-12） Number 12 m 小时中的分钟数 Number 30 s 分钟中的秒数 Number 55 S 毫秒数 Number 978 z 时区 General time zone Pacific Standard Time; PST; GMT-08:00 Z 时区 RFC 822 time zone -0800 yyyy-MM-dd 2019-03-23 构造方法 说明 SimpleDateFormat() 用默认的语言环境的日期格式符号构造SimpleDateFormat SimpleDateFormat(String pattern) 用给定的模式日期格式符号构造SimpleDateFormat 方法 说明 String format(Object obj) 格式化一个对象以生成一个字符串 Date parse(String text) 将给定的文本字符串转换为日期 public static void main(String[] args) throws Exception { Date mydate = new Date(); // SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); // SimpleDateFormat format = new SimpleDateFormat(\"MM/dd/yyyy HH:mm:ss\"); SimpleDateFormat format = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); // 1.Date转为指定格式的字符串 String str = format.format(mydate); System.out.println(str); // 2.将指定格式的字符串 转为Date System.out.println(\"---------------------------------\"); String strDate = \"2019-3-37 14:07:30\"; SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date parse = simpleDateFormat.parse(strDate); System.out.println(parse); } 8.2Calendar 方法名 说明 getInstance() 返回Calendar对象的实例 add(int field,int val) 将值val添加指定的时间或日期部分 set(int field,int val) 将值val设置到指定的时间或日期部分 get(int field) 获取指定的时间或日期部分 getTime() 返回Date对象 方法 说明 Calendar.YEAR 年份 Calendar.MONTH 月份 Calendar.DATE 日期 Calendar.DAY_OF_MONTH 日期，和上面的字段完全相同 Calendar.HOUR 12小时制小时数 Calendar.HOUR_OF_DAY 24小时制小时数 Calenday.MINUTE 分 Calendar.SECOND 秒 public class Demo05 { public static void main(String[] args) { Calendar instance = Calendar.getInstance(); // 默认当前系统时间 System.out.println(instance); System.out.println(\"提取年份:\" + instance.get(Calendar.YEAR)); System.out.println(\"提取月份:\" + (instance.get(Calendar.MONTH) + 1)); // 月份 从0开始计算 System.out.println(\"提取日期:\" + instance.get(Calendar.DAY_OF_MONTH)); System.out.println(\"提取时:\" + instance.get(Calendar.HOUR_OF_DAY)); System.out.println(\"提取分:\" + instance.get(Calendar.MINUTE)); System.out.println(\"提取秒:\" + instance.get(Calendar.SECOND)); System.out.println(\"提取毫秒:\" + instance.get(Calendar.MILLISECOND)); Date date = instance.getTime(); long m1 = date.getTime(); // 毫秒数 long m = instance.getTime().getTime(); // 毫秒数 // Date对象的getTime()用来获取从1970开始的毫秒数 // Calendar 对象的getTime()获取当前时间Date对象 // date.getTime()==calendar.getTime().getTime(); System.out.println(\"--------------------------------------------------------------------------------------\"); Calendar instance2 = Calendar.getInstance(); System.out.println(instance2); instance2.set(Calendar.YEAR, 9999); // 设置指定字段的时间 instance2.set(Calendar.MONTH, 9); instance2.set(2020, 8, 16, 20, 00); // 年月日时分 // 添加 instance2.add(Calendar.MONTH, 5); //当前时间的节点添加5个月 instance2.add(Calendar.DAY_OF_MONTH, 10); //当前时间 添加 10天 System.out.println(\"提取年份:\" + instance2.get(Calendar.YEAR)); System.out.println(\"提取月份:\" + (instance2.get(Calendar.MONTH) + 1)); //月份 从0开始计 System.out.println(\"提取日期:\" + instance2.get(Calendar.DAY_OF_MONTH)); System.out.println(\"提取时:\" + instance2.get(Calendar.HOUR_OF_DAY)); System.out.println(\"提取分:\" + instance2.get(Calendar.MINUTE)); System.out.println(\"提取秒:\" + instance2.get(Calendar.SECOND)); System.out.println(\"提取毫秒:\" + instance2.get(Calendar.MILLISECOND)); } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day11/day11.html":{"url":"content/day11/day11.html","title":"第十一章:java异常类","keywords":"","body":" 一、主要内容 二、异常的概述 三、异常处理机制 四、try....catch...finally处理异常 五、运行时异常和编译时候异常 六、throws申明抛出异常 七、throw人工抛出异常 八、自定义异常 day11_java异常处理 一、主要内容 1.异常的概述 2.异常的处理机制 3.java中异常的分类层次,常见的异常 4.使用try....catch...finally捕获异常 5.使用throws 抛出异常 6.使用throw 制造异常 7.创建自定义的异常类型 二、异常的概述 1.概述 a.任何一种程序设计语言设计的程序在运行时都有可能出现错误 b.捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。 c.对于这些错误，一般有两种解决方法： i:遇到错误就终止程序的运行。 ii:由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。 d.在Java语言中，将程序执行中发生的不正常情况称为“异常” 2.java异常的分类 a.Error:(错误)JVM系统内部错误、资源耗尽等严重情况。该异常程序员无法解决。 b.Exception:(异常)其它因编程错误或偶然的外在因素导致的一般性问题。一般都是编码问题 空指针访问 试图读取不存在的文件 网络连接中断 下标越界 除数为0.... 3.层次结构 |-Throwable:类是 Java 语言中所有错误或异常的超类 |-error:错误 |-exception:异常。是所有异常类的父类，超类; |-ClassNotFoundException: 没有找到类 |-IOException:IO流异常类 |-SQLException:SQL语句相关的异常 |-RuntimeException:运行时异常 |-ArithmeticException:除数为0异常 |-ClassCastException:类型转换异 |-NullPointerException:空指针异常 |-IndexOutOfBoundsException:索引超出范围异常 |-ArrayIndexOutOfBoundsException:数组下标越界 |-StringIndexOutOfBoundsException:字符串下标越界 三、异常处理机制 1.概述 Java异常处理机制，将异常处理的程序代码集中在一起，与正常的程序代码分开，使得程序简洁，并易于维护。 2.处理模型 Java提供的是异常处理的抛抓模型。 a.Java程序的执行过程中如出现异常，会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统，这 个过程称为抛出(throw)异常 b.如果一个方法内抛出异常，该异常会被抛到调用方法中。如果异常没有在调用方法中处理，它继续被抛给这个调 用方法的调用者。这个过程将一直继续下去，直到异常被处理。这一过程称为捕获(catch)异常。 c.如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。 d.程序员通常只能处理Exception，而对Error无能为力 四、try....catch...finally处理异常 1.关键字 a.try:将可能出现异常的代码放到try语句块中 b.catch:如果try中真的出现异常，catch捕获该异常。搭配try一起使用，不能单独使用catch c.finally:最终的。表示不管是否发生异常，最终都会被执行的代码块。关闭资源 2.语法结构 try { ...... //可能产生异常的代码 } catch( ExceptionName1 e ) { ...... //当产生ExceptionName1型异常时的处置措施 } catch( ExceptionName2 e ) { ...... //当产生ExceptionName2型异常时的处置措施 } [ finally{ ...... //无条件执行的语句 } ] 3.注意 a.一个try可以对应多个catch语句块 b.catch需要制定具体的异常类型，如果没有匹配异常，就不会被捕获 c.父类可以捕获所有的对应的子类异常类。Exception捕获所有的异常类型 d.finally语句块 可以省略。如果写了不管是否发生异常，该代码都会被执行 e.可以在catch语句块中，打印出异常的信息 e.printStackTrace() 问题:程序当中使用return，finally语句还会不会执行？如果会执行先执行谁？ 会执行,先试下finally在return。因为程序在return终止程序之前会检测有没有使用finally。 五、运行时异常和编译时候异常 a.运行时异常 程序在运行时候才会发生的异常。 就算出处理异常，java也会自动处理。(打印错误信息，程序终止) b.编译时异常|强制性异常 该异常必须要经过处理，否则编译出错。 六、throws申明抛出异常 异常处理方式: a.使用try...catch...finally自己捕获处理异常 b.throws申明抛出异常 申明抛出异常: a.如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这种异常，则此方法应显式地声明 抛出异常，表明该方法将不对这些异常进行处理，而由该方法的调用者负责处理。 b.在方法声明中用 throws 子句可以声明抛出异常的列表，throws后面的异常类型可以是方法中产生的异常类 型，也可以是它的父类。 语法结构: [修饰符] 返回值 方法名(参数列表) throws 异常1,异常2,异常3... { // 方法体 } 结论:将异常的处理权交给方法的调用者。调用者可以处理，也可以继续往上抛出.... 重写方法不能抛出比被重写方法范围更大的异常类型 public class Demo05 { public static int jisuan(int num1, int num2) { try { int result = num1 / num2; return result; } catch (Exception e) { System.out.println(\"除数不能为0\"); return 0; } } /** * 不想处理异常 运行时候异常 * * @param num1 * @param num2 * @return * @throws ArithmeticException :运行时候异常,编译时候可以不用处理 * @thwows SQLException:非运行时候异常,必须处理的异常 (测试) */ public int jisuan2(int num1, int num2) throws SQLException, RuntimeException, ArithmeticException { int result = num1 / num2; return result; } public static void main(String[] args) throws Exception { Demo05 demo05 = new Demo05(); int jisuan; try { jisuan = demo05.jisuan2(30, 0); System.out.println(\"执行结果:\" + jisuan); } catch (SQLException e) { System.out.println(\"sql异常\"); e.printStackTrace(); } catch (ArithmeticException e) { System.out.println(\"除数不能为0\"); e.printStackTrace(); } System.out.println(\"end...\"); } } 七、throw人工抛出异常 1.Java异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要人工创建并抛出 2.抛出的时候必须是Throwable|exception及其子类对象 IOException e =new IOException(); throw e; 非异常类出现语法错误: throw new String(\"want to throw\"); throws和throw两者的区别: throws: a.定义在方法名称的后面; b.该方法不主动捕获异常，而是将方法向上抛出，让调用者去处理异常 throw: a.定义在方法体的内部; b.用来主动生成一个新的异常类型; 八、自定义异常 1.用户按照需求，自己定义的异常类 2.特点: a.必须继承异常类 Execption及其子类; b.定义一个String类型参数的构造方法，用来传递错误信息 /** * 定义异常类型 * * @author THINK * */ public class MyException extends Exception { private int idnumber; public MyException(String message, int idnumber) { super(message); // 传给父类信息 显示异常的信息 this.idnumber = idnumber; } public int getIdnumber() { return idnumber; } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day12/day12.html":{"url":"content/day12/day12.html","title":"第十二章:java集合框架一","keywords":"","body":" 一、回顾 二、java集合 三、Collection 3.1迭代器 四、List 4.1 ArrayList 4.2 Vector 4.3 LinkedList 4.4.泛型 4.5 遍历集合的方式 五、Set集合 5.1 HashSet 5.2 LinkedHashSet 5.3 TreeSet 1.TreeSet添加对象 2.自定义比较器 day12_集合笔记 一、回顾 1.异常 java运行过程中发生的不正常情况，称为异常; 2.异常处理的机制 a.抛抓模型 3.异常的分类层次 Throwable:所有异常和错误类的父类 Exception:大部分异常都是由程序员代码不规范|问题造成 RuntimeException:运行时异常,必须在运行的过程中，才会发生的异常 ArithmeticException: ClassCastException: IndexOutOfBoundsException: NullPointerException: 非运行时异常|强制异常: IOException: SQLException: Error:错误，程序员无法处理 4.try...catch...finally a.try:可能出现异常的代码块; b.catch:捕获try中出现的异常 i:catch可以指定多个异常类型; ii:子类的异常类型，写在父类异常的catch块前面 iii:exception是所以异常类的父类，所以它可以接受处理所有的异常类; c.finally:是否出现异常名，最终都会被执行的语句块 finally是可以省略的,一般使用它来关闭资源，做一些善后的处理; 5.throws,throw throws: a.不使用try...catch捕获异常，直接将异常向上抛出; b.定义在方法名的后面 public void method() throws 异常类型{} throw: a.主动的抛出异常的类型(制造异常); b.在方法体的内部使用; 6.自定义异常 根据需求定义符号自己要求的异常类; a.自定义异常类必须继承exception及其子类; b.定义有参数的构造方法，传递错误的显示信息(message) 二、java集合 存储的介质： 变量:单个类型单个可变的数据 常量:单个类型单个不可变的数据 数组:单个类型的多个数据,数组的长度不可变; 集合:多个类型的多个数据,长度可变的 1.集合的概述 a.Java 集合就像一种容器，可以把多个对象的引用放入容器中。 b.Java 集合类可以用于存储数量不等的多个对象。（默认可以存在任意类型的对象） c.Java 集合可分为 Set、List 和 Map 三种体系 Set:无序，不可重复 List:有序，可重复 Map:具有映射关系的集合(key-value) d.jdk5之前，所有的集合都可以存放Object类型的数据------>导致数组中具体的元素数据类型丢失(强转) jdk5之后，引入了泛型，可以让集合记住自己是什么类型;---->List 2.java集合的架构图 Collection: List:ArrayList,LinkedList Set:HashSet,TreeSet Map: HashMap TreeMap HashTable 三、Collection 1.概述 a.Collection 接口是 List、Set 和 Queue 接口的父接口 b.该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合 2.Collection常用的方法 public static void main(String[] args) { // 创建了Collection的子类对象(使用其他也可以) Collection collection = new ArrayList<>(); Collection collection2 = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); // collection.add(false); collection2.add(\"hello world\"); collection2.add(123); // collection.addAll(c); //集合添加集合 // 移除 // collection.clear(); // 是否包含元素 System.out.println(\"是否包含:\" + collection.contains(\"hello javaxxx\")); // collection.containsAll(c);//是否包含整个集合 System.out.println(\"是否相等:\" + collection.equals(collection2)); System.out.println(\"==:\" + (collection == collection2)); System.out.println(\"hashCode:\" + collection.hashCode()); System.out.println(\"hashCode:\" + collection2.hashCode()); System.out.println(\"是否为空:\" + collection.isEmpty()); System.out.println(\"是否移除成功:\" + collection.remove(\"hello worldxxx\")); System.out.println(\"是否存在包含关系:\" + collection.retainAll(collection2)); System.out.println(collection); System.out.println(collection2); System.out.println(\"集合元素的大小:\" + collection.size()); // 转换为数组 Object[] array = collection.toArray(); for (Object object : array) { System.out.println(object); } } 3.1迭代器 作用：就是用来获取集合或者数组的中的元素。类似for循环 创建方法: 必须通过集合获取一个迭代器。 Iterator iterator = collection.iterator(); 对 collection 进行迭代的迭代器 常用的方法: hasNext():判断是否有元素可取 next():使用前进行判断，获取当前的元素 public class Demo02 { public static void main(String[] args) { Collection collection = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); collection.add(123); // 2.遍历集合 Iterator iterator = collection.iterator(); // 获取迭代器，用于迭代当前集合 while (iterator.hasNext()) { // 判断是否还有元素可以读取 Object next = iterator.next(); System.out.println(\"对应的值:\" + next); iterator.remove(); // 移除获取的元素 System.out.println(collection); } } } 增强for底层就是迭代器 public class Demo03 { public static void main(String[] args) { Collection collection = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); collection.add(123); /* * 增强for循环 */ for (Object obj : collection) { System.out.println(obj); } } } 四、List 1.概述 a.一个元素有序、且可重复的集合，集合中的每个元素都有其对应的顺序索引 b.List 允许使用重复元素，可以通过索引来访问指定位置的集合元素。 c.List 默认按元素的添加顺序设置元素的索引。 d.List 集合里添加了一些根据索引来操作集合元素的方法 简单来说:List是支持有序，可重复的元素; 2.List接口新增的方法: void add(int index, Object ele) boolean addAll(int index, Collection eles) Object get(int index) int indexOf(Object obj) int lastIndexOf(Object obj) Object remove(int index) Object set(int index, Object ele) List subList(int fromIndex, int toIndex) Collection中的所有方法，List也可以直接使用。因为Collection是List父接口; 3.List接口主要包含了三个实现类 a.ArrayList 使用数组实现,线程不同步 b.LinkedList 使用链表实现,线程不同步 c.Vector 使用数组实现,线程同步 /** * List方法的使用 * * @author THINK * */ public class Demo04 { public static void main(String[] args) { // List在 Collection基础上添加了 操作index索引的方法 List list = new ArrayList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"1\"); list.add(\"3\"); list.add(\"c\"); list.add(\"2\"); list.add(\"c\"); System.out.println(list); // 给指定位置添加元素 list.add(2, \"java\"); System.out.println(list); // 获取指定位置的元素|类似数组 Object object = list.get(0); // 下标从0开始 System.out.println(\"下标对应的内容:\" + object); // 根据元素获取下标的位置。如果不存在返回-1 int indexOf = list.indexOf(\"c\"); int last = list.lastIndexOf(\"c\"); System.out.println(\"c所在的位置:\" + indexOf); System.out.println(\"最后一次出现的位置:\" + last); // 移除 list.remove(\"c\"); // 移除元素 // list.remove(\"c\"); list.remove(1); // 如果是int类型，移除的就是集合的下标 System.out.println(list); // 替换 list.set(1, \"hello world\"); System.out.println(list); // 截取子集合（包括前面，不包括后面） List subList = list.subList(1, 3); System.out.println(list); System.out.println(subList); } } 4.1 ArrayList 1.概述 a.底层使用的是Object数组,拥有自己的下标; b.所有查询效率高(index)，添加和删除效率低(重写维护index,排序)。 c.线程不同步，线程不安全。效率高; 2.length属性,length(),和size()分别在什么时候使用: length:数组获取长度使用length; length():String字符串的时候，使用 size():集合的时候使用 int[] arr = { 1, 2, 3, 4, 5, 6 }; System.out.println(\"集合的长度:\" + arrayList.size()); System.out.println(\"字符串的长度:\" + (\"aaaa\").length()); System.out.println(\"数组的长度:\" + arr.length); // 通过 Arrays.asList创建固定长度的集合 public static void main(String[] args) { //返回固定长度的集合 List asList = Arrays.asList(\"zhangsan\", \"lisi\", \"wangwu\"); System.out.println(asList); } 4.2 Vector 1.概述 a.是ArrayList的历史版本，使用方法一样; b.Vector属于线程安全的。执行效率慢 以后不会用。 4.3 LinkedList 1.概述 a.LinkedList是基于双向链表实现 b.查询的效率较慢，但是插入和删除的效率高，只需要维护唯一前驱和后继就可以;不需要管理其他的元素 c.线程不同步，线程不安全。效率高; 提供几个新的方法: xxxFirst() xxxLast() LinkedList list = new LinkedList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.addFirst(\"kk\"); // 添加到最前面 list.addFirst(\"yy\"); // 添加到最前面 list.addLast(\"zz\"); // 添加到最后面 list.addLast(\"xx\");// 添加到最后面 Object first = list.getFirst(); System.out.println(\"第一个:\" + first); Object last = list.getLast(); System.out.println(\"最后一个:\" + last); Object removeFirst = list.removeFirst(); Object removeLast = list.removeLast(); System.out.println(\"移除第一个:\" + removeFirst); System.out.println(\"移除最后一个:\" + removeLast); 4.4.泛型 1.概念 jdk1.5之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理; jdk1.5之后，引入泛型，作用让容器(集合)记住具体的数据类型 泛型不能使用基本数据类型，基本数据类型得使用对应的包装类; int---Integer 2.语法 使用\"\" 来指定具体的泛型类型 List ====>该集合只能Integer类型的数据 3.作用 a.让容器记住具体的数据类型; b.从容器集合中获取的数据，不需要进行强转(避免出现转换异常) c.非指定的该类型的数据，其余数据无法添加。 /** * 泛型 * * @author THINK * */ public class Demo01 { public static void main(String[] args) { List arrayList = new ArrayList<>(); arrayList.add(1); arrayList.add(2); arrayList.add(3); arrayList.add(4); // arrayList.add(\"a\"); //非法 规定是Integer 传入的String // arrayList.size() ====>数组.length 获取长度 // int[] arr = { 1, 2, 3, 4, 5, 6 }; // // System.out.println(\"集合的长度:\" + arrayList.size()); // System.out.println(\"字符串的长度:\" + (\"aaaa\").length()); // System.out.println(\"数组的长度:\" + arr.length); int result = 0; // 统计集合中所有元素值得和 for (int i = 0; i 4.5 遍历集合的方式 /** * 普通for --通过下标 * * @param personList */ public static void method01(List personList) { for (int i = 0; i personList) { for (Person person : personList) { System.out.println(person); } } /** * 迭代器 * * @param personList */ public static void method03(List personList) { // 1.得到迭代器 Iterator iterator = personList.iterator(); // 2.判断迭代器有没有值可以获取 while (iterator.hasNext()) { // 3.获取 Person person = iterator.next(); System.out.println(person); } } public static void main(String[] args) { // list存放的是引用地址 List list = new ArrayList<>(); Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 20); Person wangwu = new Person(\"wangwu\", 20); Person chenliu = new Person(\"chenliu\", 20); list.add(zhangsan); list.add(lisi); list.add(wangwu); list.add(chenliu); // System.out.println(list); zhangsan.setAge(88); // 遍历List集合的三种方式 // 1.普通循环 // System.out.println(list); method03(list); // 2.增强for循环 // 3.迭代器 } 五、Set集合 1.特点 无序，不可重复; 2.概述 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法 3.常用的方法 Set父接口是Collection，所有Collection中的方法，Set也可以使用 5.1 HashSet 1.HashSet 具有以下特点： a.不能保证元素的排列顺序 b.HashSet 不是线程安全的（异步） c.集合元素可以是null 2.概述 a.HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 b.HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。 3.Set常用的方法 需要让对象相同，重写hashCode和equals方法 4.hashCode()和equals() a.hashCode() 的作用是获取哈希码,它实际上是返回一个int整数,作用是确定该对象在哈希表中的索引位置 b.hashCode()属于Object中的方法,所以所有的对象都拥有该方法; c.HashSet集合在每次add添加元素的时候，都会自定调用该元素的hashCode(); d.只有当hashCode和equals都相同的都是，HashSet会把他们看成是同一个元素;(只保留一个) e.当各个元素的hashCode()返回的值相同的时候，才会去判断equals是否相同; @Override public int hashCode() { // System.out.println(\"hashcode.....\"); // final int prime = 3333; // int result = 1; // result = prime * result + age; // result = prime * result + ((name == null) ? 0 : name.hashCode()); // 目的:尽可能的避免不同的对象的hash冲突 // name:zhangsan age:20 111+112 = 223 // name:lisi age:21 110+113 = 223 int result = age * 123 + name.hashCode(); return result; } @Override public boolean equals(Object obj) { System.out.println(\"equlas....\"); // if (this == obj) // return true; // if (obj == null) // return false; // if (getClass() != obj.getClass()) // return false; // Student other = (Student) obj; // if (age != other.age) // return false; // if (name == null) { // if (other.name != null) // return false; // } else if (!name.equals(other.name)) // return false; if (obj instanceof Student) { Student stu = (Student) obj; if (this.name.equals(stu.name) && this.age == stu.age) { return true; } } return false; } Set集合遍历方式 //增强for public static void pirntln1(Set studentSet) { for (Student student : studentSet) { System.out.println(student.getName() + \":--->\" + student.getAge()); } } //迭代器 public static void pirntln2(Set studentSet) { Iterator it = studentSet.iterator(); while (it.hasNext()) { Student student = it.next(); System.out.println(student.getName() + \":\" + student.getAge()); } } 5.2 LinkedHashSet 1.特点 具有插入顺序,不可重复; 2.概述 a.LinkedHashSet是HashSet的子类; b.Set 接口的哈希表和链表实现 c.LinkedHashSet 性能插入性能略低于 HashSet public static void main(String[] args) { Set hashSet = new LinkedHashSet<>(); hashSet.add(\"a\"); hashSet.add(\"b\"); hashSet.add(\"c\"); hashSet.add(\"d\"); hashSet.add(\"e\"); hashSet.add(\"a\"); hashSet.add(null); hashSet.add(1); System.out.println(hashSet); } //执行结果：有序,不可重复 //[a, b, c, d, e, null, 1] 5.3 TreeSet 1.概述 a.使用元素的自然顺序对元素进行排序; b.可以自定义排序 c.此实现不是同步的，线程不安全; d.TreeSet不能存放 null c.不同存放多个没有任何关系的类型 Integer和String public static void main(String[] args) { // 默认是自然排序 Set hashSet = new TreeSet<>(); hashSet.add(\"c\"); hashSet.add(\"d\"); hashSet.add(\"a\"); hashSet.add(\"b\"); hashSet.add(\"e\"); hashSet.add(\"a\"); // hashSet.add(null); // hashSet.add(1); System.out.println(hashSet); } 1.TreeSet添加对象 1.概述 TreeSet中的对象都强制需要有可比性; java提供了Comparable接口强制进行排序; 2.Comparable用法 a.自己的类实现Comparable接口; b.重写里面 compareTo()抽象方法。 返回值:负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 3.comparator用法(自定义比较器) a.创建comparator比较器 b.创建TreeSet对象的时候，初始化传入比较器 Set set = new TreeSet<>(comparator) // 1.按照age 进行排序 // 2.如果age相等，比较name //实现Comparable接口 public class Person implements Comparable { private String name; private int age; //get/set //构造方法 //toString /** * 使用该方法进行排序 */ @Override public int compareTo(Person o) { // 安装年龄进行排序 int result = this.age - o.age; System.out.println(\"比较结果------->:\" + result); // 如果年龄相同；看成是同一个对象 if (result == 0) { result = this.name.compareTo(o.name); // String的自然排序 去比较 } return result; } } public static void main(String[] args) { // 1.按照age 进行排序 // 2.如果age相等，比较name Person zhangsan = new Person(\"b\", 21); Person lisi = new Person(\"a\", 21); Person zhangsan2 = new Person(\"zhangsan\", 22); Person wangwu = new Person(\"wangwu\", 19); Person zhaoliu = new Person(\"zhaoliu\", 25); Set set = new TreeSet<>(); set.add(zhaoliu); set.add(zhangsan); set.add(lisi); set.add(zhangsan2); set.add(wangwu); System.out.println(set); } //结果 [Person [name=wangwu, age=19], Person [name=a, age=21], Person [name=b, age=21], Person [name=zhangsan, age=22], Person [name=zhaoliu, age=25]] 2.自定义比较器 /** * 创建比较器 * @author THINK * */ public class MyComparator implements Comparator { @Override public int compare(Animal o1, Animal o2) { // 比较年龄 int result = o1.getAge() - o2.getAge(); if (result == 0) { result = o1.getName().compareTo(o2.getName()); } return result; } } //使用 public class Demo06 { public static void main(String[] args) { // Collections.sort(list, c); // 创建自定义比较器 MyComparator comparator = new MyComparator(); Set treeSet = new TreeSet<>(comparator);//构造对象，指定比较器 Animal tiger = new Animal(\"m\", 5); Animal dog = new Animal(\"dog\", 8); Animal cat = new Animal(\"cat\", 9); Animal pig = new Animal(\"a\", 5); treeSet.add(dog); treeSet.add(cat); treeSet.add(pig); treeSet.add(tiger); System.out.println(treeSet); // List也可以使用 System.out.println(\"---------------------------------------------------------------\"); List arrayList = new ArrayList<>(); arrayList.add(dog); arrayList.add(cat); arrayList.add(pig); arrayList.add(tiger); System.out.println(arrayList); // 指定比较器 Collections.sort(arrayList, comparator); System.out.println(\"排序之后:\" + arrayList); } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day13/day13.html":{"url":"content/day13/day13.html","title":"第十三章:java集合框架二","keywords":"","body":" 一、回顾 二、java集合 三、Collection 3.1迭代器 四、List 4.1 ArrayList 4.2 Vector 4.3 LinkedList 4.4.泛型 4.5 遍历集合的方式 五、Set集合 5.1 HashSet 5.2 LinkedHashSet 5.3 TreeSet 1.TreeSet添加对象 2.自定义比较器 六、Map集合 6.1 HashMap 6.2 HashTable 6.3 LinkedHashMap 6.4 TreeMap 6.5 Properties 七、Collections day12_集合笔记 一、回顾 1.异常 java运行过程中发生的不正常情况，称为异常; 2.异常处理的机制 a.抛抓模型 3.异常的分类层次 Throwable:所有异常和错误类的父类 Exception:大部分异常都是由程序员代码不规范|问题造成 RuntimeException:运行时异常,必须在运行的过程中，才会发生的异常 ArithmeticException: ClassCastException: IndexOutOfBoundsException: NullPointerException: 非运行时异常|强制异常: IOException: SQLException: Error:错误，程序员无法处理 4.try...catch...finally a.try:可能出现异常的代码块; b.catch:捕获try中出现的异常 i:catch可以指定多个异常类型; ii:子类的异常类型，写在父类异常的catch块前面 iii:exception是所以异常类的父类，所以它可以接受处理所有的异常类; c.finally:是否出现异常名，最终都会被执行的语句块 finally是可以省略的,一般使用它来关闭资源，做一些善后的处理; 5.throws,throw throws: a.不使用try...catch捕获异常，直接将异常向上抛出; b.定义在方法名的后面 public void method() throws 异常类型{} throw: a.主动的抛出异常的类型(制造异常); b.在方法体的内部使用; 6.自定义异常 根据需求定义符号自己要求的异常类; a.自定义异常类必须继承exception及其子类; b.定义有参数的构造方法，传递错误的显示信息(message) 二、java集合 存储的介质： 变量:单个类型单个可变的数据 常量:单个类型单个不可变的数据 数组:单个类型的多个数据,数组的长度不可变; 集合:多个类型的多个数据,长度可变的 1.集合的概述 a.Java 集合就像一种容器，可以把多个对象的引用放入容器中。 b.Java 集合类可以用于存储数量不等的多个对象。（默认可以存在任意类型的对象） c.Java 集合可分为 Set、List 和 Map 三种体系 Set:无序，不可重复 List:有序，可重复 Map:具有映射关系的集合(key-value) d.jdk5之前，所有的集合都可以存放Object类型的数据------>导致数组中具体的元素数据类型丢失(强转) jdk5之后，引入了泛型，可以让集合记住自己是什么类型;---->List 2.java集合的架构图 Collection: List:ArrayList,LinkedList Set:HashSet,TreeSet Map: HashMap TreeMap HashTable 三、Collection 1.概述 a.Collection 接口是 List、Set 和 Queue 接口的父接口 b.该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合 2.Collection常用的方法 public static void main(String[] args) { // 创建了Collection的子类对象(使用其他也可以) Collection collection = new ArrayList<>(); Collection collection2 = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); // collection.add(false); collection2.add(\"hello world\"); collection2.add(123); // collection.addAll(c); //集合添加集合 // 移除 // collection.clear(); // 是否包含元素 System.out.println(\"是否包含:\" + collection.contains(\"hello javaxxx\")); // collection.containsAll(c);//是否包含整个集合 System.out.println(\"是否相等:\" + collection.equals(collection2)); System.out.println(\"==:\" + (collection == collection2)); System.out.println(\"hashCode:\" + collection.hashCode()); System.out.println(\"hashCode:\" + collection2.hashCode()); System.out.println(\"是否为空:\" + collection.isEmpty()); System.out.println(\"是否移除成功:\" + collection.remove(\"hello worldxxx\")); System.out.println(\"是否存在包含关系:\" + collection.retainAll(collection2)); System.out.println(collection); System.out.println(collection2); System.out.println(\"集合元素的大小:\" + collection.size()); // 转换为数组 Object[] array = collection.toArray(); for (Object object : array) { System.out.println(object); } } 3.1迭代器 作用：就是用来获取集合或者数组的中的元素。类似for循环 创建方法: 必须通过集合获取一个迭代器。 Iterator iterator = collection.iterator(); 对 collection 进行迭代的迭代器 常用的方法: hasNext():判断是否有元素可取 next():使用前进行判断，获取当前的元素 public class Demo02 { public static void main(String[] args) { Collection collection = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); collection.add(123); // 2.遍历集合 Iterator iterator = collection.iterator(); // 获取迭代器，用于迭代当前集合 while (iterator.hasNext()) { // 判断是否还有元素可以读取 Object next = iterator.next(); System.out.println(\"对应的值:\" + next); iterator.remove(); // 移除获取的元素 System.out.println(collection); } } } 增强for底层就是迭代器 public class Demo03 { public static void main(String[] args) { Collection collection = new ArrayList<>(); // 1.添加元素 add collection.add(\"hello world\"); collection.add(\"hello java\"); collection.add(123); collection.add(123); /* * 增强for循环 */ for (Object obj : collection) { System.out.println(obj); } } } 四、List 1.概述 a.一个元素有序、且可重复的集合，集合中的每个元素都有其对应的顺序索引 b.List 允许使用重复元素，可以通过索引来访问指定位置的集合元素。 c.List 默认按元素的添加顺序设置元素的索引。 d.List 集合里添加了一些根据索引来操作集合元素的方法 简单来说:List是支持有序，可重复的元素; 2.List接口新增的方法: void add(int index, Object ele) boolean addAll(int index, Collection eles) Object get(int index) int indexOf(Object obj) int lastIndexOf(Object obj) Object remove(int index) Object set(int index, Object ele) List subList(int fromIndex, int toIndex) Collection中的所有方法，List也可以直接使用。因为Collection是List父接口; 3.List接口主要包含了三个实现类 a.ArrayList 使用数组实现,线程不同步 b.LinkedList 使用链表实现,线程不同步 c.Vector 使用数组实现,线程同步 /** * List方法的使用 * * @author THINK * */ public class Demo04 { public static void main(String[] args) { // List在 Collection基础上添加了 操作index索引的方法 List list = new ArrayList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"1\"); list.add(\"3\"); list.add(\"c\"); list.add(\"2\"); list.add(\"c\"); System.out.println(list); // 给指定位置添加元素 list.add(2, \"java\"); System.out.println(list); // 获取指定位置的元素|类似数组 Object object = list.get(0); // 下标从0开始 System.out.println(\"下标对应的内容:\" + object); // 根据元素获取下标的位置。如果不存在返回-1 int indexOf = list.indexOf(\"c\"); int last = list.lastIndexOf(\"c\"); System.out.println(\"c所在的位置:\" + indexOf); System.out.println(\"最后一次出现的位置:\" + last); // 移除 list.remove(\"c\"); // 移除元素 // list.remove(\"c\"); list.remove(1); // 如果是int类型，移除的就是集合的下标 System.out.println(list); // 替换 list.set(1, \"hello world\"); System.out.println(list); // 截取子集合（包括前面，不包括后面） List subList = list.subList(1, 3); System.out.println(list); System.out.println(subList); } } 4.1 ArrayList 1.概述 a.底层使用的是Object数组,拥有自己的下标; b.所有查询效率高(index)，添加和删除效率低(重写维护index,排序)。 c.线程不同步，线程不安全。效率高; 2.length属性,length(),和size()分别在什么时候使用: length:数组获取长度使用length; length():String字符串的时候，使用 size():集合的时候使用 int[] arr = { 1, 2, 3, 4, 5, 6 }; System.out.println(\"集合的长度:\" + arrayList.size()); System.out.println(\"字符串的长度:\" + (\"aaaa\").length()); System.out.println(\"数组的长度:\" + arr.length); // 通过 Arrays.asList创建固定长度的集合 public static void main(String[] args) { //返回固定长度的集合 List asList = Arrays.asList(\"zhangsan\", \"lisi\", \"wangwu\"); System.out.println(asList); } 4.2 Vector 1.概述 a.是ArrayList的历史版本，使用方法一样; b.Vector属于线程安全的。执行效率慢 以后不会用。 4.3 LinkedList 1.概述 a.LinkedList是基于双向链表实现 b.查询的效率较慢，但是插入和删除的效率高，只需要维护唯一前驱和后继就可以;不需要管理其他的元素 c.线程不同步，线程不安全。效率高; 提供几个新的方法: xxxFirst() xxxLast() LinkedList list = new LinkedList<>(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); list.add(\"d\"); list.addFirst(\"kk\"); // 添加到最前面 list.addFirst(\"yy\"); // 添加到最前面 list.addLast(\"zz\"); // 添加到最后面 list.addLast(\"xx\");// 添加到最后面 Object first = list.getFirst(); System.out.println(\"第一个:\" + first); Object last = list.getLast(); System.out.println(\"最后一个:\" + last); Object removeFirst = list.removeFirst(); Object removeLast = list.removeLast(); System.out.println(\"移除第一个:\" + removeFirst); System.out.println(\"移除最后一个:\" + removeLast); 4.4.泛型 1.概念 jdk1.5之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object 类型处理; jdk1.5之后，引入泛型，作用让容器(集合)记住具体的数据类型 泛型不能使用基本数据类型，基本数据类型得使用对应的包装类; int---Integer 2.语法 使用\"\" 来指定具体的泛型类型 List ====>该集合只能Integer类型的数据 3.作用 a.让容器记住具体的数据类型; b.从容器集合中获取的数据，不需要进行强转(避免出现转换异常) c.非指定的该类型的数据，其余数据无法添加。 /** * 泛型 * * @author THINK * */ public class Demo01 { public static void main(String[] args) { List arrayList = new ArrayList<>(); arrayList.add(1); arrayList.add(2); arrayList.add(3); arrayList.add(4); // arrayList.add(\"a\"); //非法 规定是Integer 传入的String // arrayList.size() ====>数组.length 获取长度 // int[] arr = { 1, 2, 3, 4, 5, 6 }; // // System.out.println(\"集合的长度:\" + arrayList.size()); // System.out.println(\"字符串的长度:\" + (\"aaaa\").length()); // System.out.println(\"数组的长度:\" + arr.length); int result = 0; // 统计集合中所有元素值得和 for (int i = 0; i 4.5 遍历集合的方式 /** * 普通for --通过下标 * * @param personList */ public static void method01(List personList) { for (int i = 0; i personList) { for (Person person : personList) { System.out.println(person); } } /** * 迭代器 * * @param personList */ public static void method03(List personList) { // 1.得到迭代器 Iterator iterator = personList.iterator(); // 2.判断迭代器有没有值可以获取 while (iterator.hasNext()) { // 3.获取 Person person = iterator.next(); System.out.println(person); } } public static void main(String[] args) { // list存放的是引用地址 List list = new ArrayList<>(); Person zhangsan = new Person(\"zhangsan\", 20); Person lisi = new Person(\"lisi\", 20); Person wangwu = new Person(\"wangwu\", 20); Person chenliu = new Person(\"chenliu\", 20); list.add(zhangsan); list.add(lisi); list.add(wangwu); list.add(chenliu); // System.out.println(list); zhangsan.setAge(88); // 遍历List集合的三种方式 // 1.普通循环 // System.out.println(list); method03(list); // 2.增强for循环 // 3.迭代器 } 五、Set集合 1.特点 无序，不可重复; 2.概述 Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。 Set 判断两个对象是否相同不是使用 == 运算符，而是根据 equals 方法 3.常用的方法 Set父接口是Collection，所有Collection中的方法，Set也可以使用 5.1 HashSet 1.HashSet 具有以下特点： a.不能保证元素的排列顺序 b.HashSet 不是线程安全的（异步） c.集合元素可以是null 2.概述 a.HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。 b.HashSet 按 Hash 算法来存储集合中的元素，因此具有很好的存取和查找性能。 3.Set常用的方法 需要让对象相同，重写hashCode和equals方法 4.hashCode()和equals() a.hashCode() 的作用是获取哈希码,它实际上是返回一个int整数,作用是确定该对象在哈希表中的索引位置 b.hashCode()属于Object中的方法,所以所有的对象都拥有该方法; c.HashSet集合在每次add添加元素的时候，都会自定调用该元素的hashCode(); d.只有当hashCode和equals都相同的都是，HashSet会把他们看成是同一个元素;(只保留一个) e.当各个元素的hashCode()返回的值相同的时候，才会去判断equals是否相同; @Override public int hashCode() { // System.out.println(\"hashcode.....\"); // final int prime = 3333; // int result = 1; // result = prime * result + age; // result = prime * result + ((name == null) ? 0 : name.hashCode()); // 目的:尽可能的避免不同的对象的hash冲突 // name:zhangsan age:20 111+112 = 223 // name:lisi age:21 110+113 = 223 int result = age * 123 + name.hashCode(); return result; } @Override public boolean equals(Object obj) { System.out.println(\"equlas....\"); // if (this == obj) // return true; // if (obj == null) // return false; // if (getClass() != obj.getClass()) // return false; // Student other = (Student) obj; // if (age != other.age) // return false; // if (name == null) { // if (other.name != null) // return false; // } else if (!name.equals(other.name)) // return false; if (obj instanceof Student) { Student stu = (Student) obj; if (this.name.equals(stu.name) && this.age == stu.age) { return true; } } return false; } Set集合遍历方式 //增强for public static void pirntln1(Set studentSet) { for (Student student : studentSet) { System.out.println(student.getName() + \":--->\" + student.getAge()); } } //迭代器 public static void pirntln2(Set studentSet) { Iterator it = studentSet.iterator(); while (it.hasNext()) { Student student = it.next(); System.out.println(student.getName() + \":\" + student.getAge()); } } 5.2 LinkedHashSet 1.特点 具有插入顺序,不可重复; 2.概述 a.LinkedHashSet是HashSet的子类; b.Set 接口的哈希表和链表实现 c.LinkedHashSet 性能插入性能略低于 HashSet public static void main(String[] args) { Set hashSet = new LinkedHashSet<>(); hashSet.add(\"a\"); hashSet.add(\"b\"); hashSet.add(\"c\"); hashSet.add(\"d\"); hashSet.add(\"e\"); hashSet.add(\"a\"); hashSet.add(null); hashSet.add(1); System.out.println(hashSet); } //执行结果：有序,不可重复 //[a, b, c, d, e, null, 1] 5.3 TreeSet 1.概述 a.使用元素的自然顺序对元素进行排序; b.可以自定义排序 c.此实现不是同步的，线程不安全; d.TreeSet不能存放 null c.不同存放多个没有任何关系的类型 Integer和String public static void main(String[] args) { // 默认是自然排序 Set hashSet = new TreeSet<>(); hashSet.add(\"c\"); hashSet.add(\"d\"); hashSet.add(\"a\"); hashSet.add(\"b\"); hashSet.add(\"e\"); hashSet.add(\"a\"); // hashSet.add(null); // hashSet.add(1); System.out.println(hashSet); } 1.TreeSet添加对象 1.概述 TreeSet中的对象都强制需要有可比性; java提供了Comparable接口强制进行排序; 2.Comparable用法 a.自己的类实现Comparable接口; b.重写里面 compareTo()抽象方法。 返回值:负整数、零或正整数，根据此对象是小于、等于还是大于指定对象。 3.comparator用法(自定义比较器) a.创建comparator比较器 b.创建TreeSet对象的时候，初始化传入比较器 Set set = new TreeSet<>(comparator) // 1.按照age 进行排序 // 2.如果age相等，比较name //实现Comparable接口 public class Person implements Comparable { private String name; private int age; //get/set //构造方法 //toString /** * 使用该方法进行排序 */ @Override public int compareTo(Person o) { // 安装年龄进行排序 int result = this.age - o.age; System.out.println(\"比较结果------->:\" + result); // 如果年龄相同；看成是同一个对象 if (result == 0) { result = this.name.compareTo(o.name); // String的自然排序 去比较 } return result; } } public static void main(String[] args) { // 1.按照age 进行排序 // 2.如果age相等，比较name Person zhangsan = new Person(\"b\", 21); Person lisi = new Person(\"a\", 21); Person zhangsan2 = new Person(\"zhangsan\", 22); Person wangwu = new Person(\"wangwu\", 19); Person zhaoliu = new Person(\"zhaoliu\", 25); Set set = new TreeSet<>(); set.add(zhaoliu); set.add(zhangsan); set.add(lisi); set.add(zhangsan2); set.add(wangwu); System.out.println(set); } //结果 [Person [name=wangwu, age=19], Person [name=a, age=21], Person [name=b, age=21], Person [name=zhangsan, age=22], Person [name=zhaoliu, age=25]] 2.自定义比较器 /** * 创建比较器 * @author THINK * */ public class MyComparator implements Comparator { @Override public int compare(Animal o1, Animal o2) { // 比较年龄 int result = o1.getAge() - o2.getAge(); if (result == 0) { result = o1.getName().compareTo(o2.getName()); } return result; } } //使用 public class Demo06 { public static void main(String[] args) { // Collections.sort(list, c); // 创建自定义比较器 MyComparator comparator = new MyComparator(); Set treeSet = new TreeSet<>(comparator);//构造对象，指定比较器 Animal tiger = new Animal(\"m\", 5); Animal dog = new Animal(\"dog\", 8); Animal cat = new Animal(\"cat\", 9); Animal pig = new Animal(\"a\", 5); treeSet.add(dog); treeSet.add(cat); treeSet.add(pig); treeSet.add(tiger); System.out.println(treeSet); // List也可以使用 System.out.println(\"---------------------------------------------------------------\"); List arrayList = new ArrayList<>(); arrayList.add(dog); arrayList.add(cat); arrayList.add(pig); arrayList.add(tiger); System.out.println(arrayList); // 指定比较器 Collections.sort(arrayList, comparator); System.out.println(\"排序之后:\" + arrayList); } } 六、Map集合 1.概述 a.Map 用于保存具有映射关系的数据，因此 Map 集合里保存着两组值; key--value b.Map 中的 key 和 value 都可以是任何引用类型的数据 c.Map 中的 Key 不允许重复 d.Key 和 Value 之间存在单向一对一关系 43123 zhangsan 43234 zhangsan 2.Map接口中常用的方法 public static void main(String[] args) { Map map = new HashMap<>(); // 1.添加映射关系 map.put(\"zhagnsan\", \"广东深圳\"); map.put(\"lisi\", \"江西南昌\"); map.put(\"wangwu\", \"黑龙江\"); map.put(\"lisi\", \"江西新余\"); // key重复 会将原来的key的value替换掉 // 2.根据key获取value String string = map.get(\"wangwu\"); System.out.println(\"key对应的value===>\" + string); // 3.是否包含key,value boolean containsKey = map.containsKey(\"zhaoliu\"); boolean containsValue = map.containsValue(\"广东深圳\"); System.out.println(\"是否包含key:\" + containsKey); System.out.println(\"是否包含value:\" + containsValue); // 4.集合的大小 System.out.println(\"Map集合的大小:\" + map.size()); // map.clear(); // 清空 // 5.判断集合是否为空 boolean empty = map.isEmpty(); System.out.println(\"是否为空:\" + empty); // 6.根据key移除键值对 // String remove = map.remove(\"lisi\"); // System.out.println(\"移除:\" + remove); // 7.获取key的集合 Set keySet = map.keySet(); System.out.println(\"所有的key:\" + keySet); // 8.获取所有的value Collection values = map.values(); System.out.println(\"所有的value:\" + values); // 9.获取所有的实体 Set> entrySet = map.entrySet(); System.out.println(\"实体类:\" + entrySet); System.out.println(map); } 遍历Map的方式: 第一种:先获取key,通过key获取value 第二种:获取整个Entry实体,获取key,value（推荐） /** * 先获取key，通过key获取value * * @param map */ public static void method01(Map map) { // 1.获取key的集合 Set keySet = map.keySet(); // 2.遍历取出每一个key(增强for,迭代器) for (String key : keySet) { String value = map.get(key); System.out.println(\"key--->:\" + key + \" ------>value:\" + value); // 条件 } // 3.通过 Map中的get方法，获取value } /** * 获取 Entry Set 推荐 * * @param map */ public static void method02(Map map) { // 1.获取EntrySet集合 Set> entrySet = map.entrySet(); // 2.遍历集合 拿出Entry(迭代器和增强for) // 2.1 创建迭代器 // 2.2 判断是否还有元素 // 2.3 取出元素 Iterator> it = entrySet.iterator(); while (it.hasNext()) { // 3.通过Entry的getKey() 和getValue()获取值 Entry entry = it.next(); String key = entry.getKey(); String value = entry.getValue(); System.out.println(\"key--->:\" + key + \" ------>value:\" + value); } } 6.1 HashMap 1.特点 a.基于哈希表的 Map 接口的实现 b.允许使用 null 值和 null 键,key不能重复，只有有一个null c.此实现不是同步的，线程不安全，效率高 6.2 HashTable 1.特点 a.此类实现一个哈希表，该哈希表将键映射到相应的值 b.不能使用null作为key或者value c.Hashtable 是同步的,线程安全。效率慢 d.Hashtable 是HashMap的历史版本（不会用） 6.3 LinkedHashMap 1.特点 a.LinkedHashMap 是 HashMap 的子类 b.LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致 6.4 TreeMap 1.特点 a.该映射根据其键的自然顺序进行排序（默认） b.或者根据创建映射时提供的 Comparator 进行排序(自定义排序-自定义比较器) c.注意，此实现不是同步的 public static void main(String[] args) { // 创建map //如果需要使用自己定义的对象作为key,需要自己实现比较器( 参考TreeSet) Map treeMap = new TreeMap<>(); treeMap.put(\"c\", \"133\"); treeMap.put(\"d\", \"129\"); treeMap.put(\"a\", \"199\"); treeMap.put(\"b\", \"1125\"); println(treeMap); } public static void println(Map treeMap) { Set> entrySet = treeMap.entrySet(); for (Entry entry : entrySet) { System.out.println(entry.getKey() + \"----->\" + entry.getValue()); } } 6.5 Properties 1.特点 a.Properties 类是 Hashtable 的子类，该对象用于处理属性文件 b.由于属性文件里的 key、value 都是字符串类型 public static void main(String[] args) { Properties properties = new Properties(); properties.put(\"xx\", \"aa\"); properties.setProperty(\"bb\", \"123\"); // String object = (String) properties.get(\"xx\"); String property = properties.getProperty(\"xx\"); System.out.println(property); String property2 = properties.getProperty(\"bb\", \"默认值\"); // 如果没有找到对应key的 value显示默认值 System.out.println(property2); } 七、Collections public class Demo01 { public static void main(String[] args) { // Arrays.asList:不是具体的集合的实现，固定的长度集合 // List arrayList = Arrays.asList(\"a\", \"b\", \"c\", \"d\"); List arrayList = new ArrayList<>(); arrayList.add(\"a\"); Collections.addAll(arrayList, \"1\", \"2\", \"3\", \"4\", \"hello\"); System.out.println(arrayList); // 排序 自然顺序 Collections.sort(arrayList); System.out.println(arrayList); // Collections.shuffle(arrayList); //元素随机生成 // System.out.println(arrayList); Collections.swap(arrayList, 0, arrayList.size() - 1); // 置换位置 System.out.println(arrayList); // 更多详情查看API } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day14/day14.html":{"url":"content/day14/day14.html","title":"第十四章:javaIO流一","keywords":"","body":" 一、回顾 二、IO流 三、File 四、IO流体系 4.1 字节输入流InputStream 4.2 字节输出流OutputStream 4.3 字符输入流Reader 4.3.1 字符输入缓冲流 4.4 字符输出流 day14_io流 一、回顾 1.Collections List:有序，可重复 ArrrayList:底层数组，不安全,查询效率高; Vector:底层数组，线程安全,查询效率高; LinkedList:底层使用双向列表,添加和删除效率高，线程不安全; Set:无序，不可重复 HashSet: hash值决定存放的位置,无序，不可重复 LinkedHashSet:是HashSet的子类，多添加了链表，具有插入的顺序，不可重复 TreeSet:默认按照自然顺序排序，指定比较器 2.Map HashMap:键值对，key-value的集合 Entry== ,线程不安全，key无序，可以存放null HashTable:线程安全，不可以存放null; LinkedHashMap:key是有插入顺序 Properties:属性文件，key,value都是String类型 TreeMap:key按照自然顺序排序 Map的遍历方式: a.先获取key,通过key回去value; b.获取整个Entry,得到里面的key,value(推荐使用) 3.Iterator a.创建迭代器,Collection 里面的方式 iterator() b.hasNext()判断是否还有元素 c.next()获取元素; 4.泛型 a.让集合记住具体的数据类型,默认丢失数据类型 5.比较器 a.实体类去实现 Comparable接口, 重写里面的compareTo(T o)方法 b.创建单独的比较器 Comparator,重写里面的 int compare(T o1,T o2) 6.工具类 Colletions里面有很多提供好的方法; 二、IO流 1.流的分类 按照流向划分: 输入流:以内存为基础，从外部设备(磁盘)到内存中称为输入流; 输出流:从内容到外部设备称为输出流; 按照单位划分: 字节流:以字节为单位。（万能流,操作任意的文件(文本,图片,视频,压缩包....)） 字符流:以字符为单位，只能操作文本数据 字节输入流: 字节输出流: 字符输入流: 字符输出流: 2.概述 含义:流是指一连串流动的字符,是以先进先出方式发送信息的通道 应用场景:打印机,文件上传和下载,文件的复制粘贴; 三、File 1.概述 a.File 类代表与平台无关(window,linux)的文件和目录。 b.磁盘中只有两种东西:文件和文件夹(目录),文件有不同的类型。通过后缀区分 c.File能新建、删除、重命名文件和目录,不能访问文件中具体内容。需要(输入输出流) 2.常用方法 访问文件名: getName():获取文件名 getPath():获取文件路径名 getAbsolutePath():获取文件绝对路径名 getAbsoluteFile():获取文件绝对路径名File对象 getParent():父文件的名称,没有返回null getParentFile():父类文件的对象,没有返回null renameTo():文件的重命名 文件检测: exists():判断文件和目录是否存在 canRead():判断文件是否可读 canWrite():判断文件是否可写 isFile():判断是否是一个文件 isDirectory():判断是否是一个文件夹(目录) 获取文件的常用信息: lastModified():获取最后一个修改时间 length():获取文件的大小 文件相关操作： createNewFile():新建文件 delete():删除文件 目录相关的操作: mkdir():创建目录，创建当前层级目录; mkdirs():创建目录，如果父目录不存在，也会同时创建; list():获取该目录下所有的文件和目录的名称 listFiles():获取该目录下所有的文件和目录的File对象 3.构造方法 File(String pathname):文件或者文件夹的名称 File(String parent, String child):字符串类的文件夹和文件的名称 File(File parent, String child):File对象的文件和child字文件和目录 //构造方法使用 public static void main(String[] args) { // 根据获取对象 File file = new File(\"d://bj1901//Test01.java\"); System.out.println(file.getAbsolutePath()); System.out.println(file.lastModified()); File file2 = new File(\"d://bj1901\", \"Test01.java\"); System.out.println(file2.lastModified()); File parent = new File(\"d://bj1901\"); File file3 = new File(parent, \"Test01.java\"); System.out.println(file3.lastModified()); } 四、IO流体系 4.1 字节输入流InputStream 1.InputStream根 此抽象类是表示字节输入流的所有类的超类。 2.常用的实现类 FileInputStream: 从文件系统中的某个文件中获得输入字节 BufferedInputStream:缓冲流,作用提高效率 DataInputStream:二进制流 ObjectInputStream:对象流，用于反序列化 3.常用的方法 read():从输入流中读取数据的下一个字节,-1表示读取完毕; read(byte[] b) read(byte[] b,int off,int len); //读取文件 int len = -1; //存放读取的长度 默认-1 byte[] bytes = new byte[1024]; // int read = inputStream.read(b); // 返回值读取的长度 while ((len = inputStream.read(bytes)) != -1) { // 执行 添加数据到bytes数组 // 将数组转为字符串 // String string = new String(bytes); String string = new String(bytes, 0, len, \"UTF-8\"); System.out.println(string); } 4.2 字节输出流OutputStream 1.概述 此抽象类是表示输出字节流的所有类的超类; 2.实现类 FileOutputStream: 从文件系统中的某个文件中获得输入字节 BufferedOutputStream:缓冲流,作用提高效率 DataOutputStream:二进制流 ObjectOutputStream:对象流，用于反序列化 3.方法 public static void main(String[] args) throws IOException { OutputStream outputStream = new FileOutputStream(\"D:\\\\bj1901\\\\text.txt\", true); // true:表示追加文本，而不是覆盖 // 需要输入的内容，转为字节 String str = \"ASP.NET不错\"; byte[] bytes = str.getBytes(); outputStream.write(bytes); outputStream.flush();// 刷新 outputStream.close(); System.out.println(\"输出成功...\"); } 4.3 字符输入流Reader 1.概述 用于读取字符流的抽象类 public class Demo01 { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"D:\\\\bj1901\\\\hello.txt\"); char ch[] = new char[5]; // 字符 和 字节使用方式一样 int len = -1; while ((len = reader.read(ch)) != -1) { String string = new String(ch, 0, len); System.out.println(string); } System.out.println(\"长度:\" + len); } } 4.3.1 字符输入缓冲流 字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 如果读取到文档的末尾，返回null 优点:提高效率，可以直接读取一行; public class Demo02 { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"D:\\\\bj1901\\\\hello.txt\"); BufferedReader bufferedReader = new BufferedReader(reader); String temp = null; while ((temp = bufferedReader.readLine()) != null) { System.out.println(temp); } // 如果读取到文档的末尾，返回null reader.close(); bufferedReader.close(); } } 4.4 字符输出流 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day15/day15.html":{"url":"content/day15/day15.html","title":"第十五章:javaIO流二","keywords":"","body":" 一、回顾 二、IO流 三、File 四、IO流体系 4.1 字节输入流InputStream 4.2 字节输出流OutputStream 1.复制文件 4.3 字符输入流Reader 4.3.1 字符输入缓冲流 4.4 字符输出流 4.5 转换流 1.InputStreamReader 2.OutputStreamWriter 4.6 对象的序列化 1.序列化 和返序列化 day14_io流 一、回顾 1.Collections List:有序，可重复 ArrrayList:底层数组，不安全,查询效率高; Vector:底层数组，线程安全,查询效率高; LinkedList:底层使用双向列表,添加和删除效率高，线程不安全; Set:无序，不可重复 HashSet: hash值决定存放的位置,无序，不可重复 LinkedHashSet:是HashSet的子类，多添加了链表，具有插入的顺序，不可重复 TreeSet:默认按照自然顺序排序，指定比较器 2.Map HashMap:键值对，key-value的集合 Entry== ,线程不安全，key无序，可以存放null HashTable:线程安全，不可以存放null; LinkedHashMap:key是有插入顺序 Properties:属性文件，key,value都是String类型 TreeMap:key按照自然顺序排序 Map的遍历方式: a.先获取key,通过key回去value; b.获取整个Entry,得到里面的key,value(推荐使用) 3.Iterator a.创建迭代器,Collection 里面的方式 iterator() b.hasNext()判断是否还有元素 c.next()获取元素; 4.泛型 a.让集合记住具体的数据类型,默认丢失数据类型 5.比较器 a.实体类去实现 Comparable接口, 重写里面的compareTo(T o)方法 b.创建单独的比较器 Comparator,重写里面的 int compare(T o1,T o2) 6.工具类 Colletions里面有很多提供好的方法; 二、IO流 1.流的分类 按照流向划分: 输入流:以内存为基础，从外部设备(磁盘)到内存中称为输入流; 输出流:从内容到外部设备称为输出流; 按照单位划分: 字节流:以字节为单位。（万能流,操作任意的文件(文本,图片,视频,压缩包....)） 字符流:以字符为单位，只能操作文本数据 字节输入流: 字节输出流: 字符输入流: 字符输出流: 2.概述 含义:流是指一连串流动的字符,是以先进先出方式发送信息的通道 应用场景:打印机,文件上传和下载,文件的复制粘贴; 三、File 1.概述 a.File 类代表与平台无关(window,linux)的文件和目录。 b.磁盘中只有两种东西:文件和文件夹(目录),文件有不同的类型。通过后缀区分 c.File能新建、删除、重命名文件和目录,不能访问文件中具体内容。需要(输入输出流) 2.常用方法 访问文件名: getName():获取文件名 getPath():获取文件路径名 getAbsolutePath():获取文件绝对路径名 getAbsoluteFile():获取文件绝对路径名File对象 getParent():父文件的名称,没有返回null getParentFile():父类文件的对象,没有返回null renameTo():文件的重命名 文件检测: exists():判断文件和目录是否存在 canRead():判断文件是否可读 canWrite():判断文件是否可写 isFile():判断是否是一个文件 isDirectory():判断是否是一个文件夹(目录) 获取文件的常用信息: lastModified():获取最后一个修改时间 length():获取文件的大小 文件相关操作： createNewFile():新建文件 delete():删除文件 目录相关的操作: mkdir():创建目录，创建当前层级目录; mkdirs():创建目录，如果父目录不存在，也会同时创建; list():获取该目录下所有的文件和目录的名称 listFiles():获取该目录下所有的文件和目录的File对象 3.构造方法 File(String pathname):文件或者文件夹的名称 File(String parent, String child):字符串类的文件夹和文件的名称 File(File parent, String child):File对象的文件和child字文件和目录 //构造方法使用 public static void main(String[] args) { // 根据获取对象 File file = new File(\"d://bj1901//Test01.java\"); System.out.println(file.getAbsolutePath()); System.out.println(file.lastModified()); File file2 = new File(\"d://bj1901\", \"Test01.java\"); System.out.println(file2.lastModified()); File parent = new File(\"d://bj1901\"); File file3 = new File(parent, \"Test01.java\"); System.out.println(file3.lastModified()); } 四、IO流体系 4.1 字节输入流InputStream 1.InputStream根 此抽象类是表示字节输入流的所有类的超类。 2.常用的实现类 FileInputStream: 从文件系统中的某个文件中获得输入字节 BufferedInputStream:缓冲流,作用提高效率 DataInputStream:二进制流 ObjectInputStream:对象流，用于反序列化 3.常用的方法 read():从输入流中读取数据的下一个字节,-1表示读取完毕; read(byte[] b) read(byte[] b,int off,int len); //读取文件 int len = -1; //存放读取的长度 默认-1 byte[] bytes = new byte[1024]; // int read = inputStream.read(b); // 返回值读取的长度 while ((len = inputStream.read(bytes)) != -1) { // 执行 添加数据到bytes数组 // 将数组转为字符串 // String string = new String(bytes); String string = new String(bytes, 0, len, \"UTF-8\"); System.out.println(string); } 4.2 字节输出流OutputStream 1.概述 此抽象类是表示输出字节流的所有类的超类; 2.实现类 FileOutputStream: 从文件系统中的某个文件中获得输入字节 BufferedOutputStream:缓冲流,作用提高效率 DataOutputStream:二进制流 ObjectOutputStream:对象流，用于反序列化 3.方法 public static void main(String[] args) throws IOException { OutputStream outputStream = new FileOutputStream(\"D:\\\\bj1901\\\\text.txt\", true); // true:表示追加文本，而不是覆盖 // 需要输入的内容，转为字节 String str = \"ASP.NET不错\"; byte[] bytes = str.getBytes(); outputStream.write(bytes); outputStream.flush();// 刷新 outputStream.close(); System.out.println(\"输出成功...\"); } 1.复制文件 /** * 复制文件 * * @author THINK * */ public class Demo01 { public static void main(String[] args) throws Exception { copy02(\"D:\\\\开发工具\\\\win32_11gR2_client.zip\", \"C:\\\\\"); } /** * 复制文件:一边读取 一边写 * * @param sources 源文件的路径 * @param target 需要复制到哪个目录 * @throws IOException */ public static void copy(String sources, String target) throws IOException { // 1.创建file对象 File in = new File(sources); // 1.1 获取源文件的名称 String name = in.getName(); File out = new File(target, name); // 2.根据file创建对应的流 FileInputStream inputStream = new FileInputStream(in); // 读取源文件 FileOutputStream outputStream = new FileOutputStream(out);// 输出到指定的文件 // 3.读取(一遍读取，一遍写入 ) byte[] bytes = new byte[1024]; int len = -1; while ((len = inputStream.read(bytes)) != -1) { // 4.写到目标文件中 outputStream.write(bytes, 0, len); } // 5.关闭资源 outputStream.flush(); outputStream.close(); inputStream.close(); System.out.println(\"复制成功:\" + out.getAbsolutePath()); } /** * 复制文件:先将文件流 读取到集合 从集合写入文件 * * @param sources * @param target * @throws IOException */ public static void copy02(String sources, String target) throws IOException { List list = new ArrayList<>(); // 1.创建file对象 File in = new File(sources); // 1.1 获取源文件的名称 String name = in.getName(); File out = new File(target, name); // 2.根据file创建对应的流 FileInputStream inputStream = new FileInputStream(in); // 读取源文件 FileOutputStream outputStream = new FileOutputStream(out);// 输出到指定的文件 // 3.读取(一遍读取，一遍写入 ) byte[] bytes = new byte[1024]; int len = -1; // 20 while ((len = inputStream.read(bytes)) != -1) { if (len != bytes.length) // 最后一次读取 数组没有读满 { // 创建新的数组 存放最后读取的内容 byte by[] = new byte[len]; //by = bytes; for (int i = 0; i 4.3 字符输入流Reader 1.概述 用于读取字符流的抽象类 public class Demo01 { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"D:\\\\bj1901\\\\hello.txt\"); char ch[] = new char[5]; // 字符 和 字节使用方式一样 int len = -1; while ((len = reader.read(ch)) != -1) { String string = new String(ch, 0, len); System.out.println(string); } System.out.println(\"长度:\" + len); } } 4.3.1 字符输入缓冲流 字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 如果读取到文档的末尾，返回null 优点:提高效率，可以直接读取一行; public class Demo02 { public static void main(String[] args) throws IOException { Reader reader = new FileReader(\"D:\\\\bj1901\\\\hello.txt\"); BufferedReader bufferedReader = new BufferedReader(reader); String temp = null; while ((temp = bufferedReader.readLine()) != null) { System.out.println(temp); } // 如果读取到文档的末尾，返回null reader.close(); bufferedReader.close(); } } 4.4 字符输出流 Writer:字符输出流 提供的方法: Writer append(char c) 将指定字符添加到此 writer。 Writer append(CharSequence csq) 将指定字符序列添加到此 writer。 Writer append(CharSequence csq, int start, int end) 将指定字符序列的子序列添加到此 writer.Appendable。 abstract void close() 关闭此流，但要先刷新它。 abstract void flush() 刷新该流的缓冲。 void write(char[] cbuf) 写入字符数组。 abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分。 void write(int c) 写入单个字符。 void write(String str) 写入字符串。 void write(String str, int off, int len) 写入字符串的某一部分。 通过字符和字符缓冲流复制文件： public class Demo03 { public static void main(String[] args) throws Throwable { copy02(\"d://bj1901//test.txt\", \"C://\"); } /** * 字符流 * * @param sources * @param target * @throws Exception */ public static void copy(String sources, String target) throws Exception { File in = new File(sources); File out = new File(target, in.getName()); Reader reader = new FileReader(in); FileWriter fileWriter = new FileWriter(out); char[] ch = new char[1024]; int len = -1; while ((len = reader.read(ch)) != -1) { fileWriter.write(ch, 0, len); } fileWriter.flush(); fileWriter.close(); reader.close(); System.out.println(\"复制成功:\" + out.getAbsolutePath()); } public static void copy02(String sources, String target) throws Exception { File in = new File(sources); File out = new File(target, in.getName()); Reader reader = new FileReader(in); FileWriter fileWriter = new FileWriter(out); // 1.得到字符缓冲流 BufferedReader bufferedReader = new BufferedReader(reader); BufferedWriter bufferedWriter = new BufferedWriter(fileWriter); String str = null; while ((str = bufferedReader.readLine()) != null) { bufferedWriter.write(str); bufferedWriter.newLine(); // 换行 } bufferedWriter.flush(); bufferedWriter.close(); reader.close(); System.out.println(\"复制成功:\" + out.getAbsolutePath()); } } 4.5 转换流 字节流：万能流 字符流:只能操作文本字符，操作字符的效率比万能流更高; 字节流转为字符流: 字节输入流---->字符输入流:InputStreamReader 字节输出流---->字符输出流:OutputStreamWriter 1.InputStreamReader 1.概述 InputStreamReader 是字节流通向字符流的桥梁； 它使用的字符集可以由名称指定或显式给定，或者可以接受平台默认的字符集； 2.构造方法 InputStreamReader(InputStream in):默认字符集 InputStreamReader(InputStream in, String charsetName):指定字符集 3.常用方法 // 以后很多平台:只提供获取字节的方法 public static void main(String[] args) throws IOException { // 1.准备字节流 // FileInputStream inputStream = new FileInputStream(\"d://bj1901//Right.txt\"); // 2.转成成字符流 // Reader inputStreamReader = new InputStreamReader(inputStream); // 2.字符流转为缓冲流 // BufferedReader bufferedReader = new BufferedReader(inputStreamReader); //三句换成一句 BufferedReader bufferedReader = new BufferedReader( new InputStreamReader(new FileInputStream(\"d://bj1901//Right.txt\"))); // 3.获取流信息 String temp = null; while ((temp = bufferedReader.readLine()) != null) { System.out.println(temp); } // 关闭资源 bufferedReader.close(); // inputStreamReader.close(); // inputStream.close(); } 2.OutputStreamWriter 1.概述 OutputStreamWriter 是字符流通向字节流的桥梁 public class Demo02 { public static void main(String[] args) throws IOException { String str = \"我是中国人abcdg\"; // 1.字节 FileOutputStream outputStream = new FileOutputStream(\"d://bj1901//Right.txt\", true); OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream); //缓冲流 不是必须的 BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter); bufferedWriter.newLine(); bufferedWriter.write(str); bufferedWriter.flush(); bufferedWriter.close(); System.out.println(\"成功....\"); } } 4.6 对象的序列化 1.概述 a.对象序列化的目标是将对象保存到磁盘上，或允许在网络中直接传输对象。 b.序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制 2.实现序列化的方式 类通过实现 java.io.Serializable 接口以启用其序列化功能 1.序列化 和返序列化 将内存中的对象序列化到磁盘,是一个输出流 ObjectOutputStream: 方法:void writeObject(Object obj) public class Demo03 { public static void main(String[] args) throws Exception { //ser(); revser(); } // 序列号 public static void ser() throws FileNotFoundException, IOException { // 对象 Person person = new Person(\"zhangsan\", 12); // 集合 ALL ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"D://bj1901//zhangsan.data\")); outputStream.writeObject(person); outputStream.flush(); outputStream.close(); System.out.println(\"序列化成功....\"); } // 返序列号 public static void revser() throws Exception { ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(\"D://bj1901//zhangsan.data\")); Person person = (Person)objectInputStream.readObject(); System.out.println(person.getName()); objectInputStream.close(); } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day16/day16.html":{"url":"content/day16/day16.html","title":"第十六章:多线程一","keywords":"","body":" 一、程序、进程、线程 二、多线程的创建方式 2.1 继承Thread类 2.2 实现Runnable接口 三、线程的生命周期 四、线程的调度 4.1 线程的优先级 day16_多线程 一、程序、进程、线程 1.程序（program） 是为了让计算机执行某些操作或解决某个问题而编写的一系列有序指令的集合 。 2.进程（process） 是程序的一次执行过程，是系统运行程序的基本单位。程序是静态的，进程是动态的。 系统运行一个程序即是一个进程从创建、运行到消亡的过程。 3.线程（thread） a.比进程更小的运行单位，是程序中单个顺序的流控制。一个进程中可以包含多个线程。 b.线程是一个独立的执行流，是进程内部的一个独立执行单元，相当于一个子程序 c.一个进程中的所有线程都在该进程的虚拟地址空间中，使用该进程的全局变量和系统资源。 d.操作系统给每个线程分配不同的CPU时间片，在某一时刻，CPU只执行一个时间片内的线程，多个时间片中的相应 线程在CPU内轮流执行。 程序，进程，线程的关系: a.进程是程序的一次执行过程。 b.线程是进程的基本执行单元，一个进程包含多个线程; 多线程: 在一个进程中，开辟多个线程同时执行; 每个Java程序启动后，虚拟机将自动创建一个主线程(main) 二、多线程的创建方式 java提供两种创建线程的方式: a.创建 java.lang.Thread 类的子类，重写该类的 run方法 b.创建 java.lang.Runnable接 口的实现类，实现接口中的 run 方法 run():表示多线程执行的方法,多线程启动自动的去调用run方法; start():表示线程的启动方法，只有启动该线程，才会用多线程的方式去调用run()方法 2.1 继承Thread类 构造方法 含义 Thread() 创建一个新的线程对象 Thread(Runnable target) 基于Runnable接口实现类的实例创建一个线程对象 Thread(Runnable t, String name) 基于给定的Runnable接口实现类的实例和指定名字创建一个线程对象 Thread(String name) 基于给定的名称创建一个线程对象 //继承Thread类，重写run方法 public class MyThread extends Thread { @Override public void run() { String name2 = this.getName(); System.out.println(\"当前线程名:\" + name2); for (int i = 1; i 2.2 实现Runnable接口 1.实现Runnable接口创建线程 a.实现Runable接口; b.必须实现里面的run()方法 c.借助于Thread类，启动的线程 2.线程默认的名称:Thread-xxx 3.Runbable和Thread的区别: a.Runnable 接口必须实现 run 方法,Thread可以不重写run方法; b.Runnable 接口的实现类并不是真正的线程类，只是线程运行的目标类。要想以线程的方式执行 run 方法，必 须依靠 Thread 类 c.Runnable 接口适合于资源的共享 public class RunnableThread01 implements Runnable { @Override public void run() { // 线程执行的方法 String name = Thread.currentThread().getName(); for (int i = 1; i 三、线程的生命周期 1.生命周期 从出生到死亡过程! 2.线程的生命周期 线程从创建(start)到死亡的过程。 3.线程的运行状态 新建(初始化): new 一个线程 可执行(就绪): start()启动一个线程,可执行(需要等待CPU资源) 运行(执行):当获取CPU执行权的时候，开始执行; 阻塞:当前线程阻塞(堵车)。 死亡:出现异常，强制终止。run()正常执行完毕 四、线程的调度 线程调度 按照特定机制为线程分配 CPU 时间片段的行为 Java程序运行时，由 Java 虚拟机负责线程的调度 线程调度的实现方式 分时调度模型：让所有线程轮流获得CPU的控制权，并且为每个线程平均分配CPU时间片段 抢占式调度模型：选择优先级相对较高的线程执行，如果所有线程的优先级相同，则随机选择一个线程执行 。 Java虚拟机采用此种调度模型。 4.1 线程的优先级 分为10级 1-10（最高） powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day17/day17.html":{"url":"content/day17/day17.html","title":"第十七章:多线程二","keywords":"","body":" 一、回顾 二、线程的同步 2.1 同步代码块 2.2 同步方法 2.3 Lock实现同步 2.4同步和锁的注意事项 2.5线程同步小结 三、线程的通信|调度(wait) 四、生产者和消费者 day17_多线程01 一、回顾 1.程序，进程，线程关系 程序:为了解决现实生活中的问题编写的一系列有序指令的集合; 进程:程序的一次执行过程。进程是动态的，程序是静态的；进程之间是独立的。 线程:进程的基本执行单元,一个进程包含多个线程，线程属于某一个进程。线程可以共享同一个进程中的资源; 2.创建线程的方式 a.继承Thread类，重写run()方法【非必须】 b.实现Runnable接口,必须重写里面的run()方法 3.线程的方法 a.start():启动线程，调用run()方法 b.run():线程需要执行的方法 c.sleep():睡眠，不会释放对象锁;(占用资源) d.join():等待当前线程执行完毕 e.yield():礼让，主动释放CPU，等待重写被获取资源; f.isAlive():判断线程是否活着 g.interrupt():中断睡眠 h.getName():获取当前线程的名称 ..... j.wait():等待，会释放对象锁 k.notify():唤醒当前对象被wait的线程; 4.线程的生命周期 新建:new创建一个对象，但是没有start()启动线程 可执行(就绪):已经start()启动线程，等待CPU分配资源 运行:获取CPU资源 阻塞:sleep(),join(),IO等操作阻塞线程;----阻塞被解决回到:可执行状态 死亡:run方法执行完毕(正常|抛出异常) 5.线程的调度模型 分时调度:按照时间片段轮流分配资源; 抢占式调度:谁抢到了资源，就执行谁。随机 二、线程的同步 1.同步的概念 同步:同一时刻只能有一个。当前请求没有执行完毕，不能发起其他的请求; 异步:同时发起多个请求;多个线程同时运行 线程的同步:同一时刻，只能有一个线程进入公共资源。 2.作用 为了防止【多个线程】访问【同一个数据对象】时，对数据造成的破坏； 3.通过【锁】实现同步 java中每一个对象都有一个内置锁，当程序运行到非静态的同步方法上时，自动获得与正在执行代码类的当前实例 （this实例）有关的锁。获取对象锁也叫作对象的同步 每个对象都只有一个锁，如果一个线程获取了该对象锁，那么在该线程没有释放锁之前，任何线程都无法获取。这 也就意味着任何线程都不能进入该对象的同步方法和同步代码块 4.同步的实现方式 隐式锁:synchronized 确保共享对象在同一时刻只能被一个线程访问，这种处理机制称为“线程同步”或“线程互斥”。Java中的“线程 同步”基于“对象锁”的概念 a.同步代码块 锁住需要代码块 语法: synchronized(obj){//同步代码} 注意:保证数据安全的情况下，尽可能少的同步代码; b.同步方法 将整个方法进行同步，使用synchronized关键字修饰方法 public synchronized boolean getApple() {//同步代码} 显示锁:Lock 自己上锁和解锁，比synchronized更加灵活; 注意:解锁放在finally块解锁，避免出现异常，没有释放锁对象; 实现类: 2.1 同步代码块 //Runnable:共享资源 public class RunnableThread01 implements Runnable { int apple = 5; @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } synchronized (\"xxx\") { // 对象是随意的：必须是同一个对象 if (apple 2.2 同步方法 public class RunnableThread02 implements Runnable { private int apple = 5; @Override public void run() { while (true) { try { Thread.sleep(500); } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } boolean bool = getApple(); if (!bool) { System.out.println(\"苹果获取完毕!\"); break; } } } // 定义同步的方法 对象锁:this public synchronized boolean getApple() { if (apple 2.3 Lock实现同步 public class RunableThread03 implements Runnable { public static void main(String[] args) { RunableThread03 runableThread03 = new RunableThread03(); Thread t1 = new Thread(runableThread03, \"老黄\"); Thread t2 = new Thread(runableThread03, \"小牛\"); t1.start(); t2.start(); } // 定义车票 private int ticket = 100;// 车票 // 定义锁 private Lock lock = new ReentrantLock(); @Override public void run() { while (true) { lock.lock(); //上锁 try { if (ticket 2.4同步和锁的注意事项 只能同步方法和代码块，而不能同步变量和类； 每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？ 不必同步类中所有的方法，类可以同时拥有同步和非同步方法。 如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。 如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。 线程睡眠时，它所持的任何锁都不会释放。 线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。 不损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。 在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁 静态方法的同步，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class) 2.5线程同步小结 1、线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。 2、线程同步方法是通过锁来实现，每个对象都有且仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。 3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。 4、对于同步，要时刻清醒在哪个对象上同步，这是关键。 5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。 6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。 7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。但是，一旦程序发生死锁，程序将死掉。 三、线程的通信|调度(wait) Object中定义了三个方法，可以实现线程的调度 wait（）方法 yield() 调用了wait方法，会导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法后本线程才进入对象锁定池准备获得对象锁进入运行状态。 notify（）方法 notify的调用不释放锁，只是告诉调用过wait方法的线程可以参与获得锁的竞争了，但不是马上获得锁，要等到获得锁的线程主动释放锁才可。 notifyAll（） 和notify功能相似，它通知所有调用了wait方法的对象可以参与获得锁的竞争，单它们中只有一个有可能获得锁。 注意:使用wait和notify之前必须使用synchronized。 案例: 创建两个线程，线程一打印奇数 线程二打印偶数---->依次交替执行 package com.hzit02; /** * 创建两个线程，线程一打印奇数 线程二打印偶数---->依次交替执行 * * @author THINK * */ public class Demo01 { public static void main(String[] args) { Object obj = \"xxx\"; OddRunnable oddRunnable = new OddRunnable(obj); EvenRunnable evenRunnable = new EvenRunnable(obj); Thread odd = new Thread(oddRunnable, \"奇数线程:\"); Thread even = new Thread(evenRunnable, \"偶数线程:\"); odd.start(); even.start(); } } /** * 奇数的线程 * * @author THINK * */ class OddRunnable implements Runnable { private Object obj; public OddRunnable(Object obj) { this.obj = obj; } @Override public void run() { synchronized (obj) { // 同步的基础上使用 wait和notify 进行通信|调度 for (int i = 1; i >>>>偶数线程：\" + i); // obj.notify(); try { if (i != 100) { obj.wait(); } } catch (InterruptedException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } } } } 四、生产者和消费者 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day18/day18.html":{"url":"content/day18/day18.html","title":"第十八章:反射","keywords":"","body":" 一、回顾 二、反射(Reflection) 2.1 反射API 2.2 Class类 1.反射构造方法 2.反射属性 3.反射方法 day18_ 反射笔记 一、回顾 1.线程的同步 同步:同一时刻只能发起一个请求; 异步:同一时刻可以发起多个请求; 线程的同步:在同一个时刻，只能有一个线程执行。 作用:保护多个线程同时访问同一个资源，对资源造成破坏，数据混乱; 在保证数据安全的情况下，尽可能的少的同步代码； 同步的实现方式: 隐式锁：synchronized 每一个对象都有一个锁，自动的去上锁和解锁; 多个线程使用同一个对象锁，才会有作用; 显示锁：Lock 手动上锁。手动解锁(推荐放在finally语句块里面) 2.对象锁 a.每一个对象有且仅有一个锁; b.当一个线程获取该对象锁之后，其余线程在没有获取对象锁之前，无法调用该对象的同步方法; 3.线程的调度|通信 wait:释放该对象锁，等待锁定池，不参与锁的竞争。直到被notify唤醒或者wait时间结束; notify:唤醒当前对象被wait 等待的任意一个线程; notifyall:唤醒当前对象被wait,唤醒所有的线程，但是对象锁只有一个,最终一个线程执行。其余现在就绪。 4.生产者和消费者 a.生产者和消费者线程 b.多个线程操作的是同一个资源; 二、反射(Reflection) 1.反射 主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 2.java反射 是在运行状态中,一个类，都能够知道这个类的所有属性和方法; 对于任意一个对象，都能够调用它的任意一个方法; 这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制; 3.反射的作用 通过已知的条件(String的类路径),获取该类中所有的信息; spring 中的xml配置文件，使用了反射。 xml ===>解析xml(dom4j) 4.Java反射机制主要提供了以下功能： 在运行时构造任意一个类的对象 在运行时获取任意一个类所具有的成员变量和方法(包括私有) 在运行时调用任意一个对象的方法（属性） 生成动态代理 2.1 反射API 常用的包: java.lang.reflect; 常用的类: Class:表示反射的核心类 Field:表示字段 Method:表示方法 Constructor:表示构造器 2.2 Class类 1.概述 对象反射后可以得到的信息：某个类的数据成员名、方法和构造器、某个类到底实现了哪些接口。对于每个类而 言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个类的有关信息。 2.获取Class对象的三种方式 a.类名.class属性; b.对象名.getClass()方法 c.Class.forName(类的全路径(包名+类名) 3.常用方法 方法名 功能说明 static Class forName(String name) 返回指定类名 name 的 Class 对象 Object newInstance() 调用缺省构造函数，返回该Class对象的一个实例 getName() 返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称 Class getSuperClass() 返回当前Class对象的父类的Class对象 Class[] getInterfaces() 获取当前Class对象的接口 ClassLoader getClassLoader() 返回该类的类加载器 public static void main(String[] args) throws Exception { // com.hzit.bean.Person // 1.获取Class Class clazz = Class.forName(\"com.hzit.bean.Student\"); // 2.根据Class newInstance获取默认构造器 Object object = clazz.newInstance(); // 创建实例，调用无参构造 System.out.println(object); // 3.获取名称 String name = clazz.getName(); System.out.println(\"类路径：\" + name); // 4. 获取父类的对象 Class superclass = clazz.getSuperclass(); System.out.println(\"父类的路径:\" + superclass.getName()); // 5.获取所有的接口 Class[] interfaces = clazz.getInterfaces(); System.out.println(interfaces.length); for (Class class1 : interfaces) { System.out.println(\"父接口的名称:\" + class1.getName()); } // 6.获取当前类的包名 Package package1 = clazz.getPackage(); System.out.println(\"包名:\" + package1); } 1.反射构造方法 Constructor 提供关于类的单个构造方法的信息以及对它的访问权限 newInstance(Object... initargs):调用构造方法 **AccessibleObject** 是Constructor, Field, Method 的父类，提供了一个方法，取消java 面向对象的访问机制; 让修饰符失效。导致私有的信息，也可以被公开访问。 暴力破解:一般不推荐使用 **setAccessible**(boolean flag) true:破解 public static void main(String[] args) throws Exception { Class clazz = Class.forName(\"com.hzit.bean.Student\"); // Object newInstance = clazz.newInstance(); // 默认午餐构造 // 获取 Constructor器对象 ，需要自己手动调用 // 1.获取只有一个String类型的构造方法 (公共的构造) // Constructor constructor = clazz.getConstructor(); // 获取只有一个String类型的构造方法 // System.out.println(constructor); // constructor.newInstance(); // 调用指定的构造方法 // 2.获取所有公共的构造方法 // Constructor[] constructors = clazz.getConstructors(); // for (Constructor constructor : constructors) { // Class[] parameterTypes = constructor.getParameterTypes(); // 参数的类型 // System.out.println(\"构造方法的名称:\" + constructor); // for (Class class2 : parameterTypes) { // System.out.println(\"\\t对应的参数类型:\" + class2.getSimpleName()); // } // // if (parameterTypes.length == 0) { // 无参构造 // Object object = constructor.newInstance(); //调用无参 // } // // } // 3.获取指定类型的构造方法 包括公共和私有的 // Constructor declaredConstructor = // clazz.getDeclaredConstructor(String.class); // 4.获取所有的构造方法，包括私有的 Constructor[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor constructor : declaredConstructors) { Class[] parameterTypes = constructor.getParameterTypes(); // 参数的类型 System.out.println(\"构造方法的名称:\" + constructor); for (Class class2 : parameterTypes) { System.out.println(\"\\t对应的参数类型:\" + class2.getSimpleName()); } if (parameterTypes.length == 0) { // 无参构造 // 私有的构造 无法访问 // 暴力破解 constructor.setAccessible(true); Object object = constructor.newInstance(); // 调用无参 } } } 2.反射属性 1.Class中和Field字段相关的方法 a.Field getField(String name) ;根据指定名称获取字段。（公共的字段，本类或者父类） b.Field[] getFields();获取所有字段。（公共的字段，本类或者父类） c.Field getDeclaredField(String name);根据指定名称获取字段(本类中的字段，包括私有的) d.Field[] getDeclaredFields();获取所有字段(本类中所有的字段，包括私有的) 2.Field字段信息 Field 提供有关类或接口的单个字段的信息 常用的方法: get(Object obj) ：返回指定对象上此 Field 表示的字段的值 getXXX(Object obj); 获取指定类型数据 getInt(Object obj) setXXX(Object obj,xxx i);给该字段设置指定的值 3.反射方法 1.Class中和反射方法相关的方法 a.Method getMethod(String name, Class... parameterTypes): 参数1：方法名 参数2：参数类型 b.Method[] getMethods():获取所有的方法(本类和父类中 公共的方法) c.Method getDeclaredMethod(String name, Class... parameterTypes) :本类中指定方法(私有) d.Method[] getDeclaredMethods() 本类中所有方法(私有) 2.Method类中方法 invoke(Object obj, Object... args):调用方法 参数二:实参列表 powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day19/day19.html":{"url":"content/day19/day19.html","title":"第十九章:枚举和注解","keywords":"","body":" 一、回顾 二、枚举 三、注解 3.1 基本注解 3.2 元注解 3.3 自定义注解 3.4 提取 Annotation 信息 四、Junit单元测试 day19_枚举笔记 一、回顾 1.反射 java运行的过程中，动态的获取对象的信息，动态功能称为反射 2.作用 a.反射可以用来创建对象;(替代new) b.通过字符串格式的路径，获取该类的所有信息; 3.获取Class对象的方式 a.类名.class 属性 b.对象名.getClass()方法 c.Class.forName(\"全路径\"); clazz.newInstance():默认调用无参构造 4.反射构造方法 clazz.getConstructor(Class ... class):指定类型的公共的构造 clazz.getConstructors():获取所有公共的构造 clazz.getDeclaredConstructor(Class ... class):指定类型的构造，包括私有 clazz.getDeclaredConstructors():获取所有的构造方法(私有) Constructor构造器对象: constructor.newInstance(Object... obj):调用当前构造 setAccessible(true):设置访问私有 (field和method的私有方法也需要使用该方法) 5.反射字段 clazz.getField(String fieldName):指定的本类，父类中公共的字段 clazz.getFields():获取所有本类，父类中公共的字段 clazz.getDeclaredField(String fileName);指定的本类的字段（包括私有） clazz.getDeclaredFields():获取本类的字段（包括私有） Field字段对象: field.get(Object obj); obj表示的是object当前类的对象 field.set(Object obj,Object value); 设置字段的值 6.反射方法 clazz.getMethod(String methodName,Class ... class):指定的本类，父类中公共的方法 clazz.getMethods():获取所有本类，父类中公共的方法 clazz.getDeclaredMethod(String methodName,Class ... class);指定的本类的方法（包括私有） clazz.getDeclaredMethods():获取本类的方法（包括私有） Method方法对象: invoke(Object obj,Object ... agrs); //普通方法 //static修饰的方法 不是需要对象 invoke(null,Object ... agrs); 二、枚举 1.概念 常量的集合; 2.定义关键字 JDK 1.5 新增的 【enum】 关键字用于定义枚举类 3.枚举类和普通类的区别 -使用 enum 定义的枚举类默认继承了 java.lang.Enum 类 -枚举类的构造器只能使用 private 访问控制符 -枚举类的所有实例(对象)必须在枚举类中显式列出(, 分隔 ; 结尾). -列出的实例系统会自动添加 public static final 修饰 -所有的枚举类都提供了一个 values 方法, 该方法可以很方便地遍历所有的枚举值 JDK 1.5 中可以在 switch 表达式中使用枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定 4.枚举类的属性 枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰 枚举类使用 private final 修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数 5.枚举类的方法 三、注解 1.概述 从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 @Annotation(注解) Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理. 通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息. Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中. Annotation 能被用来为程序元素(类, 方法, 成员变量等) 设置元数据 2.注解的分类 a.基本注解 jdk默认有的注解 b.元注解 用来修饰自定义注解中的注解(修饰注解) jdk已经创建好的，可以直接使用; c.自定义注解 自己根据需求创建的注解; 关键字: @interface d.第三方注解 @Test测试 spring,mybaties,servlet....注解 必须要入第三方的依赖包 jar包 3.1 基本注解 1.常用的注解 @Override: 限定重写父类方法, 该注释只能用于方法 @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 @SuppressWarnings: 抑制编译器警告. 分为多个类型 3.2 元注解 1.概念 JDK 的元 Annotation 用于修饰其他 Annotation 定义 2.分类 @Retention:保留的时间(源码，运行时(常用),编译后)【重要】 @Target:指定注解可用于那些元素上面【重要】 @Docmented:生成文档 javadoc @Inherited:是否可以被继承 2.1 @Retention:保留的时间 分为三种情况 RetentionPolicy.SOURCE; //在.java源文件中保留 RetentionPolicy.RUNTIME //在运行时候保留(可以通过反射获取) RetentionPolicy.CLASS// 在.class文件中保留 2.2 @Target使用的范围(类，接口，包，构造器，字段，方法....) ElementType.TYPE :类，接口，枚举 ElementType.FIELD:成员变量 ElementType.METHOD:方法 ElementType.PARAMETER:参数 ElementType.CONSTRUCTOR:构造器 ElementType.LOCAL_VARIABLE:局部变量 ElementType.ANNOTATION_TYPE:注解 ElementType.PACKAGE:包 ElementType.TYPE_PARAMETER:参数 ElementType.TYPE_USE:用户 2.3 @Documented: 用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档. 2.4@Inherited: 被它修饰的 Annotation 将.如果某个类使用了被 @Inherited 修饰的 Annotation具有继承性, 则其子类将自动具有该注解 3.3 自定义注解 1.注解的关键字 @interface 2.概述 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明. 其方法名和返回值定义了该成员的 名字和类型. 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始值可使用 default 关键字 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数据 Annotation 3.4 提取 Annotation 信息 1.概述 JDK 5.0 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程 序元素 当一个 Annotation 类型被定义为运行时 Annotation 后, 该注释才是运行时可见, 当 class 文件被载入时保 存在 class 文件中的 Annotation 才会被虚拟机读取 程序可以调用 AnnotationElement 对象的如下方法来访问 Annotation 信息 四、Junit单元测试 1.步骤 a.第一步 需要导入Junit对应的jar包 b.第二部 使用注解@Test 2.@Test使用 a.只能在方法的上面使用 b.该方法不能有返回值，不能有参数列表; powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "},"content/day20/day20.html":{"url":"content/day20/day20.html","title":"第二十章:网络编程","keywords":"","body":" 一、简介 二、InetAdress 三、socket 四、ServerSocket 4.1 单向接收 day20_网络编程 一、简介 1.概述 Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应 用程序。写出来 Java提供的网络类库(java.net)，可以实现无缝的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统 里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境。 2.目的 直接或间接地通过网络协议与其它计算机进行通讯。 3.两个主要的问题 -如何准确地定位网络上一台或多台主机(IP地址) -->域名 -找到主机后如何可靠高效地进行数据传输。(网络协议) 4.TCP/IP参考模型 -TCP/IP 以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有 不同功能且互为关联的协议。 -TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即: 网络接口层 IP层 传输层 应用层 5.TCP 和 UDP -传输控制协议TCP(Transmission Control Protocol) a.面向连接的协议; b.利用TCP协议进行通信的两个应用进程，一个是服务器进程。另一个是客户进程 -用户数据报协议UDP(User Datagram Protocol)。 a.面向无连接的运输层协议 b.没有客户端和服务器之分 区别: a.TCP面向连接的，UDP面向无连接。TCP的安全度更高;(一个电话，一个是短信) b.UDP不需要连接，传输效率高更。 二、InetAdress 1.概述 此类表示互联网协议 (IP) 地址。 2.Internet上的主机有两种方式表示地址： 域名：www.hzitxx.com --->给IP地址取别名，方便记忆 IP 地址：202.108.35.210 --->计算机的唯一标识(身份证) MAC:物理地址 DNS:解析域名变成ip地址。如果DNS域名就无法访问. 端口号:标识某一台电脑上面的某一个应用程序 一台电脑上面的IP地址不能重复; 端口范围[0-65535] 但是[0-1023]系统端口，一般不建议使用 自定义端口[1024-65535]之间。有一些动:8080(tomcat),3306(mysql),1521(oracle) 3.本机的IP 192.168.1.152 127.0.0.1 localhost 4.TCP程序设计 客户端---服务器模式(请求----响应模式) 客户端－服务器模型是最常见的网络应用程序模型。当我们上网冲浪时，我们所使用的浏览器(例如IE)就是一个客户端软件，而提供网页的站点必需运行一个WEB服务器。 一般而言，主动发起通信的应用程序属于客户端。而服务器则是等待通信请求，当服务器收到客户端的请求，执行需要的运算然后向客户端返回结果。 三、socket 1.简介 客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。 2.7种基本操作 连接到远程主机 绑定到端口 接收从远程机器来的连接请求 监听到达的数据 发送数据 接收数据 关闭连接。 3.常用的方法 方法 功能 InetAddress getLocalAddress() 返回对方Socket中的IP的InetAddress对象 int getLocalPort() 返回本地Socket中的端口号 InetAddress getInetAddress() 返回对方Socket中IP地址 int getPort() 返回对方Socket中的端口号 void close() throws IOException 关闭Socket，释放资源 InputStream getInputStream() throws IOException 获取与Socket相关联的字节输入流，用于从Socket中读数据。 OutputStream getOutputStream() throws IOException 获取与Socket相关联的字节输出流，用于向Socket中写数据。 四、ServerSocket 1.概述 服务器套接字，作为服务器，等待Socket进行访问连接。 2.常用方法 方法 功能 Socket accept() throws IOException 等待客户端的连接请求，返回与该客户端进行通信用的Socket对象 void setSoTimeout(int timeout) throws SocketException 设置accept()方法等待连接的时间为timeout毫秒。若时间已到，还没有客户端连接，则抛出InterruptedIOException异常，accept()方法不再阻塞，该倾听Socket可继续使用。若timeout值为0，则表示accept()永远等待。该方法必须在倾听Socket创建后，在accept()之前调用才有效。 void close()throws IOException 关闭监听Socket InetAddress getInetAddress() 返回此服务器套接字的本地地址 int getLocalPort() 返回此套接字在其上监听的端口号 SocketAddress getLocalSocketAddress() 返回此套接字绑定的端点的地址 4.1 单向接收 客户端(socket)发送请求到服务器端(ServerSocket) 1.服务器端(ServerSocket)步骤: a.创建ServerSocket服务器，并且指定绑定的端口; b.监听客户端是否发起请求. accept()方法; c.获取输入(getInputStream())或者输出流(getOutputStream())接收，发送内容; d.关闭socket和ServerSocket 2.客户端(Socket)步骤 a.创建Socket对象,指定IP地址，以及端口号; b.获取输入(getInputStream())或者输出流(getOutputStream())接收，发送内容; c.按照指定协议发送|接收内容 d.关闭socket //服务端 package com.hzit01; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; /** * 服务器端 * * @author THINK * */ public class ServerSocketDemo { public static void main(String[] args) throws Exception { System.out.println(\"提供服务....\"); // a.创建ServerSocket服务器，并且指定绑定的端口; ServerSocket serverSocket = new ServerSocket(6666); while (true) { // b.监听客户端是否发起请求. accept()方法; Socket socket = serverSocket.accept(); // 获取访问的socket // c.获取输入(getInputStream())或者输出流(getOutputStream())接收，发送内容; InputStream inputStream = socket.getInputStream(); InputStreamReader inputStreamReader = new InputStreamReader(inputStream); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); // 获取客户端信息 InetAddress inetAddress = socket.getInetAddress(); String hostName = inetAddress.getHostName(); String hostAddress = inetAddress.getHostAddress(); int port = socket.getPort(); String temp = null; if ((temp = bufferedReader.readLine()) != null) { System.out.println(\"hostName:\" + hostName + \" ip:\" + hostAddress + \" 端口:\" + port + \" 说\" + temp); } // d.关闭socket和ServerSocket inputStream.close(); inputStreamReader.close(); bufferedReader.close(); socket.close(); } // serverSocket.close(); } } //客户端 package com.hzit01; import java.io.IOException; import java.io.OutputStream; import java.io.PrintWriter; import java.net.Socket; /** * 客户端 * * @author THINK * */ public class ClentSocket { public static void main(String[] args) throws IOException, IOException { // a.创建Socket对象,指定IP地址，以及端口号; Socket socket = new Socket(\"192.168.1.157\", 6666); // ServerSocket的地址和端口 // b.获取输入(getInputStream())或者输出流(getOutputStream())接收，发送内容; OutputStream outputStream = socket.getOutputStream(); PrintWriter pw = new PrintWriter(outputStream); pw.println(\"我是一个测试文件，来自Socket...\"); pw.flush(); pw.close(); socket.close(); // c.按照指定协议发送|接收内容 // d.关闭socket } } powered by Gitbook该文件最后修改时间： 2019-08-20 19:10:17 "}}